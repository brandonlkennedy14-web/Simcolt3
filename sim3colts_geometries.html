<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sim3colts - Boundary Discovery Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- SUPABASE CLIENT -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; }
        
        .glass-panel {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        
        @keyframes shimmer { 100% { transform: translateX(100%); } }
        .animate-shimmer { animation: shimmer 2s infinite; }
        
        /* Smooth scrolling for the UI overlay */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(56, 189, 248, 0.5); border-radius: 10px; }
    </style>
</head>
<body class="text-slate-100 h-screen w-screen font-sans">
    
    <!-- FULLSCREEN COMPOSITE SIMULATION CANVAS -->
    <canvas id="bg-canvas" class="fixed inset-0 w-full h-full z-0"></canvas>

    <!-- FOREGROUND SCROLLABLE UI LAYER -->
    <div class="absolute inset-0 z-10 flex flex-col p-3 md:p-6 pointer-events-none overflow-y-auto overflow-x-hidden">
        
        <!-- Top Navigation & Controls -->
        <div class="w-full max-w-7xl mx-auto shrink-0 pointer-events-auto">
            <div class="glass-panel rounded-2xl p-4 md:p-5 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                <div>
                    <h1 class="text-2xl md:text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-500">Boundary Discovery Engine</h1>
                    <p class="text-slate-300 text-[10px] md:text-sm mt-1">
                        Autonomous Geometric Expansion | 
                        <span id="perf-indicator" class="text-emerald-400 font-mono font-bold">Auto-Scaling...</span>
                    </p>
                </div>
                
                <div class="flex gap-4 items-center">
                    <a href="https://buymeacoffee.com/brandonkennedy" target="_blank" class="hover:scale-105 transition-transform duration-200">
                        <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 36px !important;width: 130px !important;" >
                    </a>
                </div>
            </div>

            <!-- NAVIGATION TABS -->
            <div class="mt-3 flex flex-wrap gap-3 text-[10px] md:text-xs font-mono tracking-wide">
                <a href="../index.html" class="glass-panel px-3 py-1.5 rounded-lg text-slate-400 hover:text-sky-300 transition">
                    [1] Platonic Boundary Sim
                </a>
                <a href="#" class="glass-panel px-3 py-1.5 rounded-lg text-purple-400 font-bold border-b-2 border-b-purple-400">
                    [2] Boundary Discovery Engine
                </a>
            </div>
        </div>

        <!-- TRANSPARENT VIEWING WINDOW -->
        <div class="flex-1 min-h-[45vh] md:min-h-0 pointer-events-none shrink-0"></div>

        <!-- Distributed Network HUD -->
        <div class="w-full max-w-7xl mx-auto mt-4 md:mt-auto flex flex-col md:flex-row gap-4 items-stretch md:items-end pointer-events-none shrink-0 pb-4">
            
            <!-- Telemetry Stats -->
            <div class="glass-panel p-4 md:p-5 rounded-2xl w-full md:w-64 pointer-events-auto flex flex-col justify-between">
                <div>
                    <h2 class="font-bold text-slate-200 border-b border-slate-700/50 pb-2 uppercase tracking-widest text-[10px] mb-3">Node Telemetry</h2>
                    <div class="grid grid-cols-2 md:grid-cols-1 gap-3 md:gap-4">
                        <div>
                            <span class="block text-[9px] md:text-[10px] text-slate-400 uppercase tracking-widest">Compute Ticks</span>
                            <span id="stat-ticks" class="text-lg md:text-xl font-mono text-emerald-400">0</span>
                        </div>
                        <div>
                            <span class="block text-[9px] md:text-[10px] text-slate-400 uppercase tracking-widest">Chaos Ratio</span>
                            <span id="stat-chaos" class="text-lg md:text-xl font-mono text-red-400">0.00</span>
                        </div>
                        <div>
                            <span class="block text-[9px] md:text-[10px] text-slate-400 uppercase tracking-widest">Avg Memory</span>
                            <span id="stat-winding" class="text-lg md:text-xl font-mono text-purple-400">0.00</span>
                        </div>
                        <div>
                            <span class="block text-[9px] md:text-[10px] text-slate-400 uppercase tracking-widest">Map Inversions</span>
                            <span id="stat-inversions" class="text-lg md:text-xl font-mono text-pink-400">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="mt-4 md:mt-6 bg-purple-900/30 border border-purple-500/30 p-2 md:p-3 rounded-lg text-center relative overflow-hidden">
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-purple-500/10 to-transparent -translate-x-full animate-shimmer"></div>
                    <span class="text-purple-400 font-mono text-[9px] md:text-[10px] uppercase tracking-widest flex items-center justify-center gap-2 relative z-10">
                        <span class="w-1.5 h-1.5 bg-purple-400 rounded-full shadow-[0_0_8px_#c084fc] animate-pulse"></span>
                        Discovery Active
                    </span>
                </div>
            </div>

            <!-- Supabase Sync & Logs -->
            <div class="flex-1 flex flex-col sm:flex-row md:flex-col gap-4 w-full pointer-events-auto md:max-w-sm">
                <div class="glass-panel p-4 rounded-xl flex flex-col h-32 md:h-40 flex-1">
                    <span class="block text-slate-400 text-[10px] uppercase tracking-widest mb-2 border-b border-slate-700/50 pb-1">Event Log</span>
                    <div id="log" class="flex-1 overflow-y-auto space-y-1 font-mono text-[9px] md:text-[10px] text-slate-300 break-words"></div>
                </div>
                
                <div class="glass-panel p-4 rounded-xl flex flex-col h-40 md:h-48 flex-1">
                    <span class="block text-slate-400 text-[10px] uppercase tracking-widest mb-2 border-b border-slate-700/50 pb-1 flex justify-between items-center">
                        <span>Supabase Brain</span>
                        <span class="text-emerald-500 animate-pulse text-[8px] md:text-[10px]">Live Sync</span>
                    </span>
                    <div id="museum-list" class="flex-1 overflow-y-auto space-y-2 pr-2 text-[10px] md:text-xs">
                        <div class="text-slate-500 italic text-center mt-4 text-[10px]">Connecting to Swarm...</div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script type="module">
        // --- 1. SUPABASE INTEGRATION ---
        const SUPABASE_URL = 'https://xoolmbmnzbsvcqeyqvyi.supabase.co'; 
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inhvb2xtYm1uemJzdmNxZXlxdnlpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE0NDMwNDQsImV4cCI6MjA4NzAxOTA0NH0.ebTwMZ_byU6EXtuR0jynct64QO5ornQrCwElQ5b9TxQ';

        let supabase = null;
        let dbConnected = false;
        let museumTableExists = true; 
        try {
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        } catch (e) { console.error("Supabase init error:", e); }

        // --- 2. CANVAS & RESPONSIVE SETUP ---
        const canvas = document.getElementById('bg-canvas');
        const ctx = canvas.getContext('2d');
        let width, height, CENTER_X, CENTER_Y;
        let baseScale = 1;

        // Global variables
        const ST_H = 5; 
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#4f46e5', '#a855f7'];
        let bgPattern, fgPatterns = [];

        function initPatterns() {
            let bgCanv = document.createElement('canvas');
            bgCanv.width = 1; bgCanv.height = ST_H * 7;
            let bCtx = bgCanv.getContext('2d');
            colors.forEach((c, i) => {
                bCtx.fillStyle = c;
                bCtx.fillRect(0, i * ST_H, 1, ST_H);
            });
            bgPattern = ctx.createPattern(bgCanv, 'repeat');

            fgPatterns = colors.map((c, i) => {
                let fgCanv = document.createElement('canvas');
                fgCanv.width = 1; fgCanv.height = ST_H * 7;
                let fCtx = fgCanv.getContext('2d');
                fCtx.fillStyle = c;
                fCtx.fillRect(0, i * ST_H, 1, ST_H);
                return ctx.createPattern(fgCanv, 'repeat');
            });
        }

        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            CENTER_X = width / 2;
            CENTER_Y = window.innerWidth < 768 ? height * 0.45 : height / 2;
            
            baseScale = Math.min(width, height) / 800; 
            initPatterns(); 
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); 

        // --- 3. SIMULATION CONSTANTS ---
        let CHUNK_SIZE = 300; 
        const ZETA_VOID_LIMIT = 2000; 
        
        let isRunning = false;
        let ticks = 0;
        let inversions = 0;
        let chaosRatio = 0.0;
        let knownHashes = new Set();
        let currentConfigHash = "";

        let lastFrameTime = performance.now();
        let fpsRolling = 60;
        const perfIndicator = document.getElementById('perf-indicator');

        // Dynamic Bounds that expand as blades hit them
        let bounds = { minX: -100, maxX: 100, minY: -100, maxY: 100 };
        const MAX_BOUNDS = 380;

        // --- 4. PHYSICS ENTITIES (49 BODIES) ---
        class Ball {
            constructor(groupId, isShadow = false) {
                this.groupId = groupId;
                this.color = colors[groupId];
                this.isShadow = isShadow;
                this.type = Math.random() > 0.5 ? 'smith' : 'blade';
                this.reset();
            }

            reset(perturbation = 0) {
                this.x = (Math.random() * 80 - 40);
                this.y = (Math.random() * 80 - 40);
                let angle = Math.random() * Math.PI * 2;
                let speed = this.type === 'blade' ? 2.5 : 1.2; 
                this.vx = Math.cos(angle) * speed + perturbation;
                this.vy = Math.sin(angle) * speed + perturbation;
                this.winding = 0; 
                this.ticksSinceHit = 0;
                this.path = [];
            }

            update(shadowBall) {
                this.x += this.vx;
                this.y += this.vy;
                this.ticksSinceHit++;

                if (!this.isShadow && shadowBall) {
                    let dx = this.x - shadowBall.x;
                    let dy = this.y - shadowBall.y;
                    let div = Math.sqrt(dx*dx + dy*dy);
                    chaosRatio = (chaosRatio * 0.999) + (div * 0.001); 
                }

                if (!this.isShadow && ticks % 5 === 0) {
                    this.path.push({x: this.x, y: this.y});
                    if (this.path.length > 50) this.path.shift(); 
                }

                let angle = Math.atan2(this.y, this.x);
                if (this.lastAngle !== undefined) {
                    let da = angle - this.lastAngle;
                    if (da > Math.PI) da -= 2 * Math.PI;
                    if (da < -Math.PI) da += 2 * Math.PI;
                    this.winding += da / (2 * Math.PI);
                }
                this.lastAngle = angle;

                this.checkBoundaries();
                this.checkZetaVoid();
            }

            checkBoundaries() {
                let hit = false;
                if (this.x < bounds.minX || this.x > bounds.maxX) {
                    if (this.type === 'blade') {
                        bounds.minX -= 0.05; bounds.maxX += 0.05;
                    }
                    this.vx *= -1;
                    this.x = this.x < bounds.minX ? bounds.minX : bounds.maxX;
                    hit = true;
                }
                if (this.y < bounds.minY || this.y > bounds.maxY) {
                    if (this.type === 'blade') {
                        bounds.minY -= 0.05; bounds.maxY += 0.05; 
                    }
                    this.vy *= -1;
                    this.y = this.y < bounds.minY ? bounds.minY : bounds.maxY;
                    hit = true;
                }
                if (hit) this.ticksSinceHit = 0;
            }

            checkZetaVoid() {
                if (this.ticksSinceHit > ZETA_VOID_LIMIT) {
                    this.x *= 0.1; this.y *= 0.1;
                    this.vx *= -1; this.vy *= -1;
                    this.ticksSinceHit = 0;
                }
            }
        }

        let balls = [], shadowBalls = [];

        function generateHash() {
            let str = balls.map(b => `${b.type}_${b.vx.toFixed(1)}_${b.vy.toFixed(1)}`).join('|');
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = Math.imul(31, hash) + str.charCodeAt(i) | 0;
            return "Discovery_" + Math.abs(hash).toString(16);
        }

        function initBalls() {
            balls = []; shadowBalls = [];
            bounds = { minX: -100, maxX: 100, minY: -100, maxY: 100 };
            inversions = 0;
            chaosRatio = 0;
            ticks = 0;

            for (let g = 0; g < 7; g++) {
                for (let i = 0; i < 7; i++) {
                    let b = new Ball(g, false);
                    balls.push(b);
                    let shadow = new Ball(g, true);
                    shadow.x = b.x; shadow.y = b.y;
                    shadow.vx = b.vx + 1e-7; shadow.vy = b.vy + 1e-7;
                    shadowBalls.push(shadow);
                }
            }
            currentConfigHash = generateHash();
            if (knownHashes.has(currentConfigHash)) initBalls(); 
        }

        function applyExclusionPrinciple() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    let dx = balls[i].x - balls[j].x;
                    let dy = balls[i].y - balls[j].y;
                    if (dx*dx + dy*dy < 25) { 
                        let b1 = balls[i], b2 = balls[j];
                        if (Math.abs(b1.winding) < 0.1) {
                            b1.vx = (Math.random() - 0.5) * 15; b1.vy = (Math.random() - 0.5) * 15;
                        }
                        if (Math.abs(b1.winding) > Math.abs(b2.winding)) {
                            b2.vx *= -1.08; b2.vy *= -1.08; 
                        } else {
                            b1.vx *= -1.08; b1.vy *= -1.08;
                        }
                    }
                }
            }
        }

        function checkInversion() {
            if (bounds.maxX - bounds.minX > MAX_BOUNDS * 2) { 
                inversions++;
                bounds = { minX: -20, maxX: 20, minY: -20, maxY: 20 }; 
                balls.forEach(b => { b.x *= 0.1; b.y *= 0.1; b.vx *= -1; b.vy *= -1; });
                document.getElementById('log').innerHTML = `<div class="text-pink-400 font-bold">Map Inversion ${inversions} triggered! [Discovery Core Collapsed]</div>` + document.getElementById('log').innerHTML.slice(0, 300);
            }
        }

        function checkPerformance() {
            const now = performance.now();
            const dt = now - lastFrameTime;
            lastFrameTime = now;
            
            const currentFps = 1000 / dt;
            fpsRolling = (fpsRolling * 0.9) + (currentFps * 0.1);

            if (fpsRolling < 30) {
                CHUNK_SIZE = Math.max(50, CHUNK_SIZE - 20);
                perfIndicator.textContent = "Compute: Throttled (Low Rig)";
                perfIndicator.className = "text-red-400 font-mono font-bold text-[10px] md:text-xs";
            } else if (fpsRolling > 55) {
                CHUNK_SIZE = Math.min(800, CHUNK_SIZE + 10);
                perfIndicator.textContent = "Compute: Unleashed (Max Yield)";
                perfIndicator.className = "text-emerald-400 font-mono font-bold text-[10px] md:text-xs";
            }
        }

        function drawMaster() {
            ctx.clearRect(0, 0, width, height);

            if (bgPattern) {
                ctx.fillStyle = bgPattern;
                ctx.fillRect(0, 0, width, height);
            }

            // Darken outside the dynamic expanding bounds
            ctx.fillStyle = 'rgba(15, 23, 42, 0.7)';
            ctx.beginPath();
            ctx.rect(0, 0, width, height); 
            ctx.rect(CENTER_X + bounds.minX*baseScale, CENTER_Y + bounds.minY*baseScale, (bounds.maxX - bounds.minX)*baseScale, (bounds.maxY - bounds.minY)*baseScale);
            ctx.fill("evenodd");

            ctx.lineWidth = 1.5;
            ctx.globalCompositeOperation = 'hard-light'; 
            let maxDist = (bounds.maxX - bounds.minX) * 0.3 * baseScale; 

            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    let dx = balls[i].x*baseScale - balls[j].x*baseScale;
                    let dy = balls[i].y*baseScale - balls[j].y*baseScale;
                    if (Math.abs(dx) > maxDist || Math.abs(dy) > maxDist) continue;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < maxDist) {
                        ctx.beginPath();
                        ctx.moveTo(CENTER_X + balls[i].x*baseScale, CENTER_Y + balls[i].y*baseScale);

                        let warpX = (balls[i].vx + balls[j].vx) * 10 * baseScale;
                        let warpY = (balls[i].vy + balls[j].vy) * 10 * baseScale;

                        ctx.bezierCurveTo(
                            CENTER_X + balls[i].x*baseScale + warpX, CENTER_Y + balls[i].y*baseScale - warpY, 
                            CENTER_X + balls[j].x*baseScale - warpX, CENTER_Y + balls[j].y*baseScale + warpY, 
                            CENTER_X + balls[j].x*baseScale, CENTER_Y + balls[j].y*baseScale
                        );

                        let opacity = (1 - dist / maxDist) * 0.8;
                        let grad = ctx.createLinearGradient(CENTER_X + balls[i].x*baseScale, CENTER_Y + balls[i].y*baseScale, CENTER_X + balls[j].x*baseScale, CENTER_Y + balls[j].y*baseScale);
                        grad.addColorStop(0, balls[i].color + Math.floor(opacity*255).toString(16).padStart(2,'0'));
                        grad.addColorStop(1, balls[j].color + Math.floor(opacity*255).toString(16).padStart(2,'0'));
                        
                        ctx.strokeStyle = grad;
                        ctx.stroke();
                    }
                }
            }
            ctx.globalCompositeOperation = 'source-over';

            for (let g = 0; g < 7; g++) {
                let groupBalls = balls.filter(b => b.groupId === g);
                
                groupBalls.forEach(b => {
                    if (b.path.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(CENTER_X + b.path[0].x*baseScale, CENTER_Y + b.path[0].y*baseScale);
                        for (let i = 1; i < b.path.length; i++) {
                            let xc = CENTER_X + (b.path[i-1].x + b.path[i].x)/2 * baseScale;
                            let yc = CENTER_Y + (b.path[i-1].y + b.path[i].y)/2 * baseScale;
                            ctx.quadraticCurveTo(CENTER_X + b.path[i-1].x*baseScale, CENTER_Y + b.path[i-1].y*baseScale, xc, yc);
                        }
                        ctx.lineTo(CENTER_X + b.x*baseScale, CENTER_Y + b.y*baseScale);
                        
                        ctx.lineWidth = b.type === 'smith' ? 4 : 2; 
                        ctx.strokeStyle = '#94a3b8'; ctx.stroke(); 
                        if(fgPatterns[g]) {
                            ctx.strokeStyle = fgPatterns[g]; ctx.stroke(); 
                        }
                    }
                });

                groupBalls.forEach(b => {
                    ctx.beginPath();
                    ctx.arc(CENTER_X + b.x*baseScale, CENTER_Y + b.y*baseScale, (b.type === 'smith' ? 8 : 5) * baseScale, 0, Math.PI * 2);
                    ctx.fillStyle = '#94a3b8'; ctx.fill();
                    if(fgPatterns[g]) {
                        ctx.fillStyle = fgPatterns[g]; ctx.fill();
                    }
                });
            }
            
            // Draw Dynamic Outline
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 3;
            ctx.strokeRect(CENTER_X + bounds.minX*baseScale, CENTER_Y + bounds.minY*baseScale, (bounds.maxX - bounds.minX)*baseScale, (bounds.maxY - bounds.minY)*baseScale);
        }

        function runChunk() {
            if (!isRunning) return;
            checkPerformance();

            for(let c=0; c < CHUNK_SIZE; c++) {
                balls.forEach((b, i) => b.update(shadowBalls[i]));
                shadowBalls.forEach(b => b.update(null)); 
                applyExclusionPrinciple();
                checkInversion();
                ticks++;
            }

            drawMaster();

            if (dbConnected && museumTableExists && ticks % 30000 === 0 && chaosRatio < 8.0 && !knownHashes.has(currentConfigHash)) {
                saveStructureToSupabase();
            }

            document.getElementById('stat-ticks').textContent = ticks.toLocaleString();
            document.getElementById('stat-chaos').textContent = chaosRatio.toFixed(2);
            document.getElementById('stat-inversions').textContent = inversions;
            document.getElementById('stat-winding').textContent = (balls.reduce((sum, b) => sum + Math.abs(b.winding), 0) / 49).toFixed(2);

            requestAnimationFrame(runChunk);
        }

        async function saveStructureToSupabase() {
            if (!supabase || !dbConnected || !museumTableExists) return;
            knownHashes.add(currentConfigHash);
            try {
                const { error } = await supabase.from('museum').upsert({ 
                    hash: currentConfigHash, chaos_ratio: chaosRatio.toFixed(2), inversions, tick_detected: ticks 
                });
                if (error) {
                     if (error.code === 'PGRST205' || error.code === '42P01') {
                         console.error("Supabase upsert error: Table 'museum' not found.");
                         museumTableExists = false;
                     } else {
                         console.error("Supabase upsert error:", error);
                     }
                } else {
                    document.getElementById('log').innerHTML = `<div class="text-emerald-400">Yield Found! Logged: ${currentConfigHash.substring(0,8)}</div>` + document.getElementById('log').innerHTML.slice(0, 300);
                }
            } catch (e) { console.error(e); }
        }

        function loadMuseumSupabase() {
            if (!supabase) return;
            
            const list = document.getElementById('museum-list');
            
            supabase.from('museum').select('*').order('created_at', { ascending: false }).limit(20)
                .then(({ data, error }) => {
                    if (error) {
                        if (error.code !== 'PGRST205' && error.code !== '42P01') {
                            console.error("Supabase fetch error:", error);
                        }
                        
                        dbConnected = false;
                        if (error.code === 'PGRST205' || error.code === '42P01') {
                            museumTableExists = false;
                            list.innerHTML = `<div class="text-red-400 italic text-center mt-4 text-[10px] p-2 border border-red-500/30 bg-red-900/20 rounded">Table 'museum' missing in Supabase.<br>Simulation running in local mode.</div>`;
                        } else {
                            list.innerHTML = `<div class="text-yellow-500 italic text-center mt-4 text-[10px]">Database connection error. Local mode active.</div>`;
                        }
                        return;
                    }
                    dbConnected = true;
                    museumTableExists = true;
                    renderMuseum(data || []);
                    
                    supabase.channel('custom-all-channel')
                        .on('postgres_changes', { event: '*', schema: 'public', table: 'museum' }, payload => {
                            document.getElementById('log').innerHTML = `<div class="text-purple-400">Swarm Sync...</div>` + document.getElementById('log').innerHTML.slice(0, 300);
                            supabase.from('museum').select('*').order('created_at', { ascending: false }).limit(20)
                                .then(({ data, error }) => {
                                    if (!error) renderMuseum(data || []);
                                });
                        }).subscribe();
                })
                .catch(err => {
                     console.error("Supabase connection error:", err);
                     dbConnected = false;
                     list.innerHTML = `<div class="text-yellow-500 italic text-center mt-4 text-[10px]">Database connection error. Local mode active.</div>`;
                });
        }

        function renderMuseum(data) {
            const list = document.getElementById('museum-list');
            
            if (!data || data.length === 0) {
                list.innerHTML = `<div class="text-slate-500 italic text-center mt-4 text-[10px]">No structures found yet.</div>`;
                return;
            }
            
            list.innerHTML = '';
            data.forEach(item => {
                knownHashes.add(item.hash);
                let geoLabel = item.hash.includes('_') ? item.hash.split('_')[0] : 'Discovery';
                let shortHash = item.hash.includes('_') ? item.hash.split('_')[1].substring(0,8) : item.hash.substring(0,8);
                
                list.innerHTML += `
                    <div class="bg-slate-800/80 p-2 rounded text-[10px] border border-slate-700 font-mono">
                        <div class="flex justify-between mb-1">
                            <span class="text-purple-300 font-bold">${geoLabel}</span>
                            <span class="text-slate-400">#${shortHash}</span>
                        </div>
                        <div class="flex justify-between text-slate-500">
                            <span>Inv: ${item.inversions}</span>
                            <span>C: ${item.chaos_ratio}</span>
                        </div>
                    </div>
                `;
            });
        }

        initBalls();
        loadMuseumSupabase();
        isRunning = true;
        runChunk(); 
    </script>
</body>
</html>