<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sim3colts - Unified Learning Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; background-color: #020617; font-family: sans-serif; }

        /* ‚îÄ‚îÄ SPLASH ‚îÄ‚îÄ */
        #splash {
            position: fixed; inset: 0; z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            background: #020617;
        }
        #splash canvas {
            position: absolute; inset: 0; width: 100%; height: 100%;
        }
        .splash-card {
            position: relative; z-index: 10;
            background: rgba(15,23,42,0.75);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148,163,184,0.15);
            box-shadow: 0 40px 80px -20px rgba(0,0,0,0.8);
            border-radius: 24px;
            padding: 48px 40px 40px;
            max-width: 520px; width: 92%;
            text-align: center;
        }
        .version-btn {
            display: block; width: 100%;
            border-radius: 14px;
            padding: 20px 24px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34,1.56,0.64,1);
            text-align: left;
            margin-bottom: 14px;
            position: relative;
            overflow: hidden;
        }
        .version-btn:hover { transform: scale(1.025); }
        .version-btn::before {
            content: ''; position: absolute; inset: 0;
            opacity: 0; transition: opacity 0.2s;
        }
        .version-btn:hover::before { opacity: 1; }
        .v1-btn {
            background: rgba(56,189,248,0.08);
            border-color: rgba(56,189,248,0.3);
        }
        .v1-btn:hover { background: rgba(56,189,248,0.15); border-color: rgba(56,189,248,0.6); box-shadow: 0 0 30px rgba(56,189,248,0.2); }
        .v2-btn {
            background: rgba(168,85,247,0.08);
            border-color: rgba(168,85,247,0.3);
            margin-bottom: 0;
        }
        .v2-btn:hover { background: rgba(168,85,247,0.15); border-color: rgba(168,85,247,0.6); box-shadow: 0 0 30px rgba(168,85,247,0.2); }
        .btn-tag {
            font-size: 9px; font-weight: 700; letter-spacing: 0.15em;
            text-transform: uppercase; font-family: monospace;
            padding: 2px 8px; border-radius: 99px; margin-bottom: 8px;
            display: inline-block;
        }
        .splash-fade-out {
            animation: splashFade 0.6s ease forwards;
        }
        @keyframes splashFade {
            to { opacity: 0; pointer-events: none; }
        }

        /* ‚îÄ‚îÄ SHARED UI ‚îÄ‚îÄ */
        .glass-panel {
            background: rgba(15,23,42,0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(148,163,184,0.2);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }
        select { background-color: #0f172a; color: #38bdf8; border: 1px solid #334155; outline: none; }

        /* ‚îÄ‚îÄ CONTAINERS ‚îÄ‚îÄ */
        #v1-root, #v2-root { display: none; position: fixed; inset: 0; }
        #v1-root.active, #v2-root.active { display: block; }

        /* ‚îÄ‚îÄ V2 EXTRAS ‚îÄ‚îÄ */
        #v2-museum-toast {
            position: fixed; bottom: 24px; left: 50%;
            transform: translateX(-50%) translateY(80px);
            transition: transform 0.4s cubic-bezier(0.34,1.56,0.64,1), opacity 0.4s;
            opacity: 0; z-index: 100; pointer-events: none;
        }
        #v2-museum-toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        @keyframes pulse-badge { 0%,100%{opacity:1} 50%{opacity:0.3} }
        #v2-deep-badge { display:none; animation: pulse-badge 1.2s ease-in-out infinite; }
        #v2-deep-badge.active { display: inline-block; }
    </style>
</head>
<body>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     SPLASH SCREEN
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div id="splash">
    <canvas id="splash-canvas"></canvas>
    <div class="splash-card">
        <div style="font-size:11px;font-family:monospace;letter-spacing:0.2em;color:#475569;text-transform:uppercase;margin-bottom:8px;">sim3colts</div>
        <h1 style="font-size:28px;font-weight:800;background:linear-gradient(135deg,#38bdf8,#a855f7);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin:0 0 6px;">Unified Learning Engine</h1>
        <p style="font-size:13px;color:#64748b;margin:0 0 32px;">Choose your simulation environment</p>

        <button class="version-btn v1-btn" onclick="launchVersion('v1')">
            <span class="btn-tag" style="background:rgba(56,189,248,0.15);color:#38bdf8;">Original</span>
            <div style="font-size:17px;font-weight:700;color:#e2e8f0;margin-bottom:4px;">V1 ‚Äî Classic Engine</div>
            <div style="font-size:12px;color:#64748b;line-height:1.5;">The original sim ‚Äî preserved exactly as trained. Platonic boundaries, discovery mode, and all accumulated museum knowledge intact.</div>
            <div style="margin-top:10px;font-size:10px;font-family:monospace;color:#38bdf8;opacity:0.7;">Exclusion: 25 ¬∑ Trail: 50 ¬∑ Classic render</div>
        </button>

        <button class="version-btn v2-btn" onclick="launchVersion('v2')">
            <span class="btn-tag" style="background:rgba(168,85,247,0.15);color:#a855f7;">Enhanced</span>
            <div style="font-size:17px;font-weight:700;color:#e2e8f0;margin-bottom:4px;">V2 ‚Äî Deep Scan Engine</div>
            <div style="font-size:12px;color:#64748b;line-height:1.5;">Wall heat maps, winding-number visuals, deep scan remapping at 3 resolution levels, and richer museum logging ‚Äî all on the same shared knowledge base.</div>
            <div style="margin-top:10px;font-size:10px;font-family:monospace;color:#a855f7;opacity:0.7;">Exclusion: 25‚Üí10‚Üí4 ¬∑ Deep scan ¬∑ Parent hash tree</div>
        </button>

        <div style="margin-top:20px;font-size:10px;color:#334155;font-family:monospace;">
            Both versions share the same Supabase museum ¬∑ Knowledge is never lost
        </div>
    </div>
</div>


<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     V1 ROOT ‚Äî ORIGINAL, UNTOUCHED
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div id="v1-root">
    <canvas id="v1-canvas" style="position:fixed;inset:0;width:100%;height:100%;z-index:0;"></canvas>
    <div style="position:absolute;inset:0;z-index:10;display:flex;flex-direction:column;padding:12px;pointer-events:none;" class="md:p-6">
        <div style="width:100%;max-width:1280px;margin:0 auto;flex-shrink:0;pointer-events:auto;">
            <div class="glass-panel" style="border-radius:16px;padding:16px 20px;display:flex;justify-content:space-between;align-items:center;border-top:2px solid rgba(56,189,248,0.5);">
                <div>
                    <h1 id="v1-engine-title" style="font-size:20px;font-weight:700;background:linear-gradient(to right,#38bdf8,#6366f1);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">Platonic Boundary Sim</h1>
                    <div id="v1-geo-selector-container" style="display:flex;align-items:center;gap:8px;margin-top:8px;">
                        <span style="color:#94a3b8;font-size:10px;text-transform:uppercase;letter-spacing:0.1em;font-weight:700;">Domain:</span>
                        <select id="v1-geo-select" style="background:#0f172a;color:#38bdf8;border:1px solid #334155;padding:2px 6px;border-radius:4px;font-size:10px;font-family:monospace;cursor:pointer;">
                            <option value="Square">Square</option>
                            <option value="Triangle">Equilateral Triangle</option>
                            <option value="Hexagon">Regular Hexagon</option>
                            <option value="Octagon">Regular Octagon</option>
                            <option value="Circle">Circular Domain</option>
                        </select>
                    </div>
                </div>
                <div style="display:flex;gap:16px;align-items:center;">
                    <span id="v1-perf-indicator" style="font-size:10px;font-family:monospace;color:#34d399;text-transform:uppercase;font-weight:700;">Compute: Balanced</span>
                    <button onclick="returnToSplash()" style="font-size:10px;font-family:monospace;color:#475569;background:rgba(71,85,105,0.2);border:1px solid #334155;border-radius:8px;padding:4px 10px;cursor:pointer;">‚á¶ SWITCH</button>
                    <a href="https://buymeacoffee.com/brandonkennedy" target="_blank" style="transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform=''">
                        <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height:32px;width:115px;">
                    </a>
                </div>
            </div>
            <div style="margin-top:12px;display:flex;flex-wrap:wrap;gap:12px;font-size:10px;font-family:monospace;letter-spacing:0.05em;">
                <button id="v1-tab-platonic" class="glass-panel" style="padding:8px 16px;border-radius:8px;color:#38bdf8;font-weight:700;border-bottom:2px solid #38bdf8;cursor:pointer;background:none;">[1] PLATONIC BOUNDARIES</button>
                <button id="v1-tab-discovery" class="glass-panel" style="padding:8px 16px;border-radius:8px;color:#94a3b8;cursor:pointer;background:none;border:none;">[2] DISCOVERY ENGINE</button>
            </div>
        </div>
    </div>
</div>


<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     V2 ROOT ‚Äî ENHANCED ENGINE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div id="v2-root">
    <canvas id="v2-canvas" style="position:fixed;inset:0;width:100%;height:100%;z-index:0;"></canvas>
    <div style="position:absolute;inset:0;z-index:10;display:flex;flex-direction:column;padding:12px;pointer-events:none;">
        <div style="width:100%;max-width:1280px;margin:0 auto;flex-shrink:0;pointer-events:auto;">
            <div class="glass-panel" style="border-radius:16px;padding:16px 20px;display:flex;justify-content:space-between;align-items:center;border-top:2px solid rgba(168,85,247,0.5);">
                <div>
                    <div style="display:flex;align-items:center;gap:12px;">
                        <h1 id="v2-engine-title" style="font-size:20px;font-weight:700;background:linear-gradient(to right,#38bdf8,#6366f1);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">Platonic Boundary Sim</h1>
                        <span id="v2-deep-badge" style="font-size:9px;font-family:monospace;font-weight:700;padding:2px 8px;border-radius:99px;background:rgba(245,158,11,0.2);color:#f59e0b;border:1px solid rgba(245,158,11,0.4);">‚¨° DEEP SCAN</span>
                    </div>
                    <div id="v2-geo-selector-container" style="display:flex;align-items:center;gap:8px;margin-top:8px;">
                        <span style="color:#94a3b8;font-size:10px;text-transform:uppercase;letter-spacing:0.1em;font-weight:700;">Domain:</span>
                        <select id="v2-geo-select" style="background:#0f172a;color:#38bdf8;border:1px solid #334155;padding:2px 6px;border-radius:4px;font-size:10px;font-family:monospace;cursor:pointer;">
                            <option value="Square">Square</option>
                            <option value="Triangle">Equilateral Triangle</option>
                            <option value="Hexagon">Regular Hexagon</option>
                            <option value="Octagon">Regular Octagon</option>
                            <option value="Circle">Circular Domain</option>
                        </select>
                    </div>
                    <div style="display:flex;gap:16px;margin-top:8px;font-size:9px;font-family:monospace;color:#475569;">
                        <span>CHAOS: <span id="v2-stat-chaos" style="color:#34d399;">0.00</span></span>
                        <span>INV: <span id="v2-stat-inv" style="color:#38bdf8;">0</span></span>
                        <span>MUSEUM: <span id="v2-stat-museum" style="color:#a855f7;">0</span></span>
                        <span>SCAN LVL: <span id="v2-stat-scan" style="color:#f59e0b;">1</span></span>
                    </div>
                </div>
                <div style="display:flex;gap:16px;align-items:center;">
                    <span id="v2-perf-indicator" style="font-size:10px;font-family:monospace;color:#34d399;text-transform:uppercase;font-weight:700;">Compute: Balanced</span>
                    <button onclick="returnToSplash()" style="font-size:10px;font-family:monospace;color:#475569;background:rgba(71,85,105,0.2);border:1px solid #334155;border-radius:8px;padding:4px 10px;cursor:pointer;">‚á¶ SWITCH</button>
                    <a href="https://buymeacoffee.com/brandonkennedy" target="_blank" style="transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform=''">
                        <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height:32px;width:115px;">
                    </a>
                </div>
            </div>
            <div style="margin-top:12px;display:flex;flex-wrap:wrap;gap:12px;font-size:10px;font-family:monospace;letter-spacing:0.05em;">
                <button id="v2-tab-platonic" class="glass-panel" style="padding:8px 16px;border-radius:8px;color:#38bdf8;font-weight:700;border-bottom:2px solid #38bdf8;cursor:pointer;background:none;">[1] PLATONIC BOUNDARIES</button>
                <button id="v2-tab-discovery" class="glass-panel" style="padding:8px 16px;border-radius:8px;color:#94a3b8;cursor:pointer;background:none;border:none;">[2] DISCOVERY ENGINE</button>
            </div>
        </div>
    </div>
    <!-- Toast -->
    <div id="v2-museum-toast" class="glass-panel" style="position:fixed;bottom:24px;left:50%;border:1px solid rgba(168,85,247,0.4);border-radius:12px;padding:12px 20px;text-align:center;pointer-events:none;">
        <div id="v2-toast-icon" style="font-size:18px;margin-bottom:4px;">üèõÔ∏è</div>
        <div id="v2-toast-title" style="font-size:11px;font-weight:700;color:#c4b5fd;font-family:monospace;"></div>
        <div id="v2-toast-sub" style="font-size:10px;color:#64748b;margin-top:2px;"></div>
    </div>
</div>


<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     SHARED SUPABASE + SPLASH LOGIC
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script>
    // ‚îÄ‚îÄ Shared Supabase client (both versions read/write here) ‚îÄ‚îÄ
    // Project: inversion_sim_db ‚Äî xoolmbmnzbsvcqeyqvyi.supabase.co
    const SUPABASE_URL = 'https://xoolmbmnzbsvcqeyqvyi.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inhvb2xtYm1uemJzdmNleXhxdnlpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE0NDMwNDQsImV4cCI6MjA4NzAxOTA0NH0.ebTwMZ_byU6EXtuR0jynct64QO5ornQrCwElQ5b9TxQ';
    const sharedSupabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const sharedKnownHashes = new Set(); // both versions share this in-memory set
    let sharedDbConnected = false;

    // Genesis Brain ‚Äî publish sim3 state so other apps can read it via WS push
    const GB_HDRS = {
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': 'Bearer ' + SUPABASE_ANON_KEY,
        'Content-Type': 'application/json',
        'Prefer': 'resolution=merge-duplicates,return=minimal'
    };
    let _gbV = 0, _gbLast = 0;
    function gbWriteSim3(payload) {
        const now = Date.now();
        if (now - _gbLast < 500) return; // max 2 writes/sec
        _gbLast = now;
        fetch(SUPABASE_URL + '/rest/v1/genesis_brain', {
            method: 'POST', headers: GB_HDRS,
            body: JSON.stringify({ namespace: 'sim3', version: ++_gbV, payload: { ...payload, _ts: now } })
        }).catch(() => {});
    }

    // Load museum hashes once, shared by both versions
    function loadSharedMuseum(onReady) {
        sharedSupabase.from('museum').select('hash,chaos_ratio,inversions').limit(5000).then(({ data, error }) => {
            if (error) {
                // Museum table may not exist yet ‚Äî sim still runs, just won't skip known configs
                console.warn('Museum load failed (table may need creating):', error.message);
                console.info('Run in Supabase SQL Editor: CREATE TABLE IF NOT EXISTS museum (hash text primary key, chaos_ratio text, tick_detected bigint, inversions int, version text, scan_level int, exclusion_dist int, trail_len int, parent_hash text, created_at timestamptz default now());');
            } else if (data) {
                data.forEach(item => sharedKnownHashes.add(item.hash));
                console.log(`Museum loaded: ${data.length} known configurations`);
                sharedDbConnected = true;
            }
            // Always subscribe for live inserts ‚Äî catches new discoveries from other sessions
            try {
                sharedSupabase.channel('unified-channel')
                    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'museum' }, payload => {
                        if (payload.new?.hash) sharedKnownHashes.add(payload.new.hash);
                    }).subscribe();
            } catch(e) {}
            onReady(); // always launch ‚Äî never block on DB
        }).catch(e => {
            console.warn('Museum unreachable:', e);
            onReady(); // still launch
        });
    }

    // ‚îÄ‚îÄ Splash animation ‚îÄ‚îÄ
    (function() {
        const sc = document.getElementById('splash-canvas');
        const sctx = sc.getContext('2d');
        const splashBalls = [];
        const splashColors = ['#ef4444','#f97316','#eab308','#22c55e','#3b82f6','#4f46e5','#a855f7'];

        function resizeSplash() { sc.width = window.innerWidth; sc.height = window.innerHeight; }
        resizeSplash();
        window.addEventListener('resize', resizeSplash);

        for (let i = 0; i < 35; i++) {
            splashBalls.push({
                x: Math.random() * sc.width, y: Math.random() * sc.height,
                vx: (Math.random()-0.5)*1.2, vy: (Math.random()-0.5)*1.2,
                r: Math.random()*3+1, color: splashColors[i % 7],
                path: []
            });
        }

        function animSplash() {
            if (!document.getElementById('splash').style.display !== 'none') return;
            sctx.fillStyle = 'rgba(2,6,23,0.18)';
            sctx.fillRect(0, 0, sc.width, sc.height);
            splashBalls.forEach(b => {
                b.x += b.vx; b.y += b.vy;
                if (b.x < 0 || b.x > sc.width) b.vx *= -1;
                if (b.y < 0 || b.y > sc.height) b.vy *= -1;
                b.path.push({x:b.x,y:b.y});
                if (b.path.length > 60) b.path.shift();

                if (b.path.length > 1) {
                    sctx.beginPath();
                    sctx.moveTo(b.path[0].x, b.path[0].y);
                    for (let i=1; i<b.path.length; i++) sctx.lineTo(b.path[i].x, b.path[i].y);
                    sctx.strokeStyle = b.color + '44'; sctx.lineWidth = 1; sctx.stroke();
                }

                // Connect nearby balls
                splashBalls.forEach(b2 => {
                    let dx=b.x-b2.x, dy=b.y-b2.y, d=Math.sqrt(dx*dx+dy*dy);
                    if (d < 120 && d > 0) {
                        sctx.beginPath(); sctx.moveTo(b.x,b.y); sctx.lineTo(b2.x,b2.y);
                        sctx.strokeStyle = b.color + Math.floor((1-d/120)*40).toString(16).padStart(2,'0');
                        sctx.lineWidth=0.5; sctx.stroke();
                    }
                });

                sctx.beginPath(); sctx.arc(b.x,b.y,b.r,0,Math.PI*2);
                sctx.fillStyle = b.color + 'cc'; sctx.fill();
            });
            requestAnimationFrame(animSplash);
        }
        animSplash();
    })();

    // ‚îÄ‚îÄ Version launch ‚îÄ‚îÄ
    let activeVersion = null;
    let v1Loop = null, v2Loop = null;

    function launchVersion(v) {
        const splash = document.getElementById('splash');
        splash.classList.add('splash-fade-out');
        setTimeout(() => { splash.style.display = 'none'; }, 600);

        activeVersion = v;
        document.getElementById('v1-root').classList.toggle('active', v === 'v1');
        document.getElementById('v2-root').classList.toggle('active', v === 'v2');

        loadSharedMuseum(() => {
            if (v === 'v1') initV1();
            else initV2();
        });
    }

    function returnToSplash() {
        // Pause both loops
        if (v1Loop) { cancelAnimationFrame(v1Loop); v1Loop = null; }
        if (v2Loop) { cancelAnimationFrame(v2Loop); v2Loop = null; }
        document.getElementById('v1-root').classList.remove('active');
        document.getElementById('v2-root').classList.remove('active');
        const splash = document.getElementById('splash');
        splash.style.display = 'flex';
        splash.style.opacity = '1';
        splash.classList.remove('splash-fade-out');
    }
</script>


<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     V1 ENGINE ‚Äî ORIGINAL CODE, ZERO CHANGES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script>
function initV1() {
    // All V1 state is scoped inside this function ‚Äî completely isolated
    const colors = ['#ef4444','#f97316','#eab308','#22c55e','#3b82f6','#4f46e5','#a855f7'];
    const ST_H = 5;
    const ZETA_VOID_LIMIT = 2000;

    const canvas = document.getElementById('v1-canvas');
    const ctx = canvas.getContext('2d');
    let width, height, CENTER_X, CENTER_Y, baseScale = 1;
    let bgPattern, fgPatterns = [];

    function initPatterns() {
        let bgCanv = document.createElement('canvas');
        bgCanv.width = 1; bgCanv.height = ST_H * 7;
        let bCtx = bgCanv.getContext('2d');
        colors.forEach((c, i) => { bCtx.fillStyle = c; bCtx.fillRect(0, i * ST_H, 1, ST_H); });
        bgPattern = ctx.createPattern(bgCanv, 'repeat');
        fgPatterns = colors.map((c, i) => {
            let fgCanv = document.createElement('canvas');
            fgCanv.width = 1; fgCanv.height = ST_H * 7;
            let fCtx = fgCanv.getContext('2d');
            fCtx.fillStyle = c; fCtx.fillRect(0, i * ST_H, 1, ST_H);
            return ctx.createPattern(fgCanv, 'repeat');
        });
    }

    function resizeCanvas() {
        width = window.innerWidth; height = window.innerHeight;
        canvas.width = width; canvas.height = height;
        CENTER_X = width / 2; CENTER_Y = height / 2;
        baseScale = Math.min(width, height) / 800;
        initPatterns();
    }

    let simMode = 'platonic';
    let currentGeoName = 'Square';
    let ticks = 0, inversions = 0, chaosRatio = 0.0;
    let currentConfigHash = '';
    let CHUNK_SIZE = 300, lastFrameTime = performance.now(), fpsRolling = 60;
    let discoveryBounds = { minX: -150, maxX: 150, minY: -150, maxY: 150 };

    const geometries = {
        'Square':   { type:'poly', basePoints:[[-150,-150],[150,-150],[150,150],[-150,150]], scale:1 },
        'Triangle': { type:'poly', basePoints:[[0,-180],[156,90],[-156,90]], scale:1 },
        'Hexagon':  { type:'poly', basePoints:[], scale:1 },
        'Octagon':  { type:'poly', basePoints:[], scale:1 },
        'Circle':   { type:'circle', baseRadius:150, scale:1 }
    };
    for(let i=0;i<6;i++) geometries['Hexagon'].basePoints.push([Math.cos(i*Math.PI/3-Math.PI/6)*165,Math.sin(i*Math.PI/3-Math.PI/6)*165]);
    for(let i=0;i<8;i++) geometries['Octagon'].basePoints.push([Math.cos(i*Math.PI/4-Math.PI/8)*160,Math.sin(i*Math.PI/4-Math.PI/8)*160]);
    let activeGeo = geometries['Square'];

    function getScaledPoints() {
        if (activeGeo.type !== 'poly') return [];
        return activeGeo.basePoints.map(p => [p[0]*activeGeo.scale, p[1]*activeGeo.scale]);
    }

    class Ball {
        constructor(groupId, isShadow=false) {
            this.groupId = groupId;
            this.color = colors[groupId];
            this.isShadow = isShadow;
            this.type = Math.random() > 0.5 ? 'smith' : 'blade';
            this.reset();
        }
        reset() {
            this.x = (Math.random()*80-40); this.y = (Math.random()*80-40);
            let speed = this.type==='blade'?2.5:1.2;
            let angle = Math.random()*Math.PI*2;
            this.vx = Math.cos(angle)*speed; this.vy = Math.sin(angle)*speed;
            this.winding = 0; this.ticksSinceHit = 0;
            this.path = []; this.lastAngle = undefined;
        }
        update(shadowBall) {
            this.x += this.vx; this.y += this.vy; this.ticksSinceHit++;
            if (!this.isShadow && shadowBall) {
                let dx=this.x-shadowBall.x, dy=this.y-shadowBall.y;
                chaosRatio = (chaosRatio*0.999) + (Math.sqrt(dx*dx+dy*dy)*0.001);
            }
            if (!this.isShadow && ticks % 5 === 0) {
                this.path.push({x:this.x,y:this.y});
                if (this.path.length > 50) this.path.shift();
            }
            let angle = Math.atan2(this.y, this.x);
            if (this.lastAngle !== undefined) {
                let da = angle - this.lastAngle;
                if (da > Math.PI) da -= 2*Math.PI;
                if (da < -Math.PI) da += 2*Math.PI;
                this.winding += da / (2*Math.PI);
            }
            this.lastAngle = angle;
            this.checkBoundaries();
            if (this.ticksSinceHit > ZETA_VOID_LIMIT) {
                this.x*=0.1; this.y*=0.1; this.vx*=-1; this.vy*=-1; this.ticksSinceHit=0;
            }
        }
        checkBoundaries() {
            let hit = false;
            if (simMode === 'discovery') {
                if (this.x < discoveryBounds.minX || this.x > discoveryBounds.maxX) {
                    if (this.type==='blade'){discoveryBounds.minX-=0.05;discoveryBounds.maxX+=0.05;}
                    this.vx*=-1; this.x=this.x<discoveryBounds.minX?discoveryBounds.minX:discoveryBounds.maxX;
                    hit=true;
                }
                if (this.y < discoveryBounds.minY || this.y > discoveryBounds.maxY) {
                    if (this.type==='blade'){discoveryBounds.minY-=0.05;discoveryBounds.maxY+=0.05;}
                    this.vy*=-1; this.y=this.y<discoveryBounds.minY?discoveryBounds.minY:discoveryBounds.maxY;
                    hit=true;
                }
            } else {
                if (activeGeo.type === 'circle') {
                    let r=activeGeo.baseRadius*activeGeo.scale;
                    if (this.x*this.x+this.y*this.y > r*r) {
                        if (this.type==='blade') activeGeo.scale+=0.0002;
                        let dist=Math.sqrt(this.x*this.x+this.y*this.y);
                        let nx=this.x/dist, ny=this.y/dist;
                        let dot=this.vx*nx+this.vy*ny;
                        if (dot>0){this.vx-=2*dot*nx;this.vy-=2*dot*ny;this.x=nx*r;this.y=ny*r;hit=true;}
                    }
                } else {
                    let pts=getScaledPoints();
                    for (let i=0;i<pts.length;i++){
                        let p1=pts[i],p2=pts[(i+1)%pts.length];
                        let nx=-(p2[1]-p1[1]),ny=p2[0]-p1[0];
                        let len=Math.sqrt(nx*nx+ny*ny);nx/=len;ny/=len;
                        if(nx*(-p1[0])+ny*(-p1[1])<0){nx=-nx;ny=-ny;}
                        let d=(this.x-p1[0])*nx+(this.y-p1[1])*ny;
                        if(d<0){
                            if(this.type==='blade') activeGeo.scale+=0.0002;
                            let dot=this.vx*(-nx)+this.vy*(-ny);
                            if(dot>0){this.vx-=2*dot*(-nx);this.vy-=2*dot*(-ny);this.x-=d*nx;this.y-=d*ny;hit=true;}
                        }
                    }
                }
            }
            if(hit) this.ticksSinceHit=0;
        }
    }

    let balls=[], shadowBalls=[];

    function generateHash() {
        let str=balls.map(b=>`${b.type}_${b.vx.toFixed(1)}_${b.vy.toFixed(1)}`).join('|');
        let hash=0;
        for(let i=0;i<str.length;i++) hash=Math.imul(31,hash)+str.charCodeAt(i)|0;
        if(simMode==='discovery'){
            let currentBoundSize=Math.floor(discoveryBounds.maxX-discoveryBounds.minX);
            return `Disc_W${currentBoundSize}_${Math.abs(hash).toString(16)}`;
        }
        return `${currentGeoName}_${Math.abs(hash).toString(16)}`;
    }

    function initBalls() {
        balls=[]; shadowBalls=[];
        discoveryBounds={minX:-150,maxX:150,minY:-150,maxY:150};
        activeGeo.scale=1.0; ticks=0; chaosRatio=0; inversions=0;
        for(let g=0;g<7;g++){
            for(let i=0;i<7;i++){
                let b=new Ball(g,false); balls.push(b);
                let s=new Ball(g,true); s.x=b.x;s.y=b.y;s.vx=b.vx+1e-7;s.vy=b.vy+1e-7;
                shadowBalls.push(s);
            }
        }
        currentConfigHash=generateHash();
        if(sharedKnownHashes.has(currentConfigHash)) initBalls();
    }

    function applyExclusionPrinciple() {
        for(let i=0;i<balls.length;i++){
            for(let j=i+1;j<balls.length;j++){
                let dx=balls[i].x-balls[j].x, dy=balls[i].y-balls[j].y;
                if(dx*dx+dy*dy < 25){
                    let b1=balls[i],b2=balls[j];
                    if(Math.abs(b1.winding)<0.1){b1.vx=(Math.random()-0.5)*15;b1.vy=(Math.random()-0.5)*15;}
                    if(Math.abs(b1.winding)>Math.abs(b2.winding)){b2.vx*=-1.08;b2.vy*=-1.08;}
                    else{b1.vx*=-1.08;b1.vy*=-1.08;}
                }
            }
        }
    }

    function checkInversion() {
        if(simMode==='platonic'&&activeGeo.scale>4.5){
            inversions++; activeGeo.scale=0.5;
            balls.forEach(b=>{b.x*=0.1;b.y*=0.1;b.vx*=-1;b.vy*=-1;});
        } else if(simMode==='discovery'&&(discoveryBounds.maxX-discoveryBounds.minX>760)){
            inversions++;
            discoveryBounds={minX:-50,maxX:50,minY:-50,maxY:50};
            balls.forEach(b=>{b.x*=0.1;b.y*=0.1;b.vx*=-1;b.vy*=-1;});
        }
    }

    function draw() {
        ctx.clearRect(0,0,width,height);
        ctx.fillStyle=bgPattern; ctx.fillRect(0,0,width,height);
        ctx.fillStyle='rgba(2,6,23,0.7)';
        ctx.beginPath(); ctx.rect(0,0,width,height);
        if(simMode==='discovery'){
            ctx.rect(CENTER_X+discoveryBounds.minX*baseScale,CENTER_Y+discoveryBounds.minY*baseScale,(discoveryBounds.maxX-discoveryBounds.minX)*baseScale,(discoveryBounds.maxY-discoveryBounds.minY)*baseScale);
        } else if(activeGeo.type==='circle'){
            ctx.arc(CENTER_X,CENTER_Y,activeGeo.baseRadius*activeGeo.scale*baseScale,0,Math.PI*2,true);
        } else {
            let pts=getScaledPoints(); ctx.moveTo(CENTER_X+pts[0][0]*baseScale,CENTER_Y+pts[0][1]*baseScale);
            for(let i=pts.length-1;i>=0;i--) ctx.lineTo(CENTER_X+pts[i][0]*baseScale,CENTER_Y+pts[i][1]*baseScale);
        }
        ctx.fill('evenodd');

        ctx.lineWidth=1.5;
        ctx.globalCompositeOperation='hard-light';
        let maxDist=(simMode==='discovery'?150:150*activeGeo.scale)*baseScale;
        for(let i=0;i<balls.length;i++){
            for(let j=i+1;j<balls.length;j++){
                let dx=balls[i].x*baseScale-balls[j].x*baseScale;
                let dy=balls[i].y*baseScale-balls[j].y*baseScale;
                if(Math.abs(dx)>maxDist||Math.abs(dy)>maxDist) continue;
                let dist=Math.sqrt(dx*dx+dy*dy);
                if(dist<maxDist){
                    ctx.beginPath();
                    ctx.moveTo(CENTER_X+balls[i].x*baseScale,CENTER_Y+balls[i].y*baseScale);
                    let warpX=(balls[i].vx+balls[j].vx)*10*baseScale;
                    let warpY=(balls[i].vy+balls[j].vy)*10*baseScale;
                    ctx.bezierCurveTo(
                        CENTER_X+balls[i].x*baseScale+warpX,CENTER_Y+balls[i].y*baseScale-warpY,
                        CENTER_X+balls[j].x*baseScale-warpX,CENTER_Y+balls[j].y*baseScale+warpY,
                        CENTER_X+balls[j].x*baseScale,CENTER_Y+balls[j].y*baseScale
                    );
                    let opacity=(1-dist/maxDist)*0.8;
                    let grad=ctx.createLinearGradient(CENTER_X+balls[i].x*baseScale,CENTER_Y+balls[i].y*baseScale,CENTER_X+balls[j].x*baseScale,CENTER_Y+balls[j].y*baseScale);
                    grad.addColorStop(0,balls[i].color+Math.floor(opacity*255).toString(16).padStart(2,'0'));
                    grad.addColorStop(1,balls[j].color+Math.floor(opacity*255).toString(16).padStart(2,'0'));
                    ctx.strokeStyle=grad; ctx.stroke();
                }
            }
        }
        ctx.globalCompositeOperation='source-over';

        for(let g=0;g<7;g++){
            let groupBalls=balls.filter(b=>b.groupId===g);
            groupBalls.forEach(b=>{
                if(b.path.length>0){
                    ctx.beginPath();
                    ctx.moveTo(CENTER_X+b.path[0].x*baseScale,CENTER_Y+b.path[0].y*baseScale);
                    for(let i=1;i<b.path.length;i++){
                        let xc=CENTER_X+(b.path[i-1].x+b.path[i].x)/2*baseScale;
                        let yc=CENTER_Y+(b.path[i-1].y+b.path[i].y)/2*baseScale;
                        ctx.quadraticCurveTo(CENTER_X+b.path[i-1].x*baseScale,CENTER_Y+b.path[i-1].y*baseScale,xc,yc);
                    }
                    ctx.lineTo(CENTER_X+b.x*baseScale,CENTER_Y+b.y*baseScale);
                    ctx.lineWidth=b.type==='smith'?4:2;
                    ctx.strokeStyle='#94a3b8'; ctx.stroke();
                    if(fgPatterns[g]){ctx.strokeStyle=fgPatterns[g];ctx.stroke();}
                }
            });
            groupBalls.forEach(b=>{
                ctx.beginPath();
                ctx.arc(CENTER_X+b.x*baseScale,CENTER_Y+b.y*baseScale,(b.type==='smith'?8:5)*baseScale,0,Math.PI*2);
                ctx.fillStyle='#94a3b8'; ctx.fill();
                if(fgPatterns[g]){ctx.fillStyle=fgPatterns[g];ctx.fill();}
            });
        }

        ctx.strokeStyle='#334155'; ctx.lineWidth=3;
        if(simMode==='discovery'){
            ctx.strokeRect(CENTER_X+discoveryBounds.minX*baseScale,CENTER_Y+discoveryBounds.minY*baseScale,(discoveryBounds.maxX-discoveryBounds.minX)*baseScale,(discoveryBounds.maxY-discoveryBounds.minY)*baseScale);
        } else if(activeGeo.type==='circle'){
            ctx.beginPath();ctx.arc(CENTER_X,CENTER_Y,activeGeo.baseRadius*activeGeo.scale*baseScale,0,Math.PI*2);ctx.stroke();
        } else {
            let pts=getScaledPoints();
            ctx.beginPath();ctx.moveTo(CENTER_X+pts[0][0]*baseScale,CENTER_Y+pts[0][1]*baseScale);
            for(let i=1;i<pts.length;i++) ctx.lineTo(CENTER_X+pts[i][0]*baseScale,CENTER_Y+pts[i][1]*baseScale);
            ctx.closePath();ctx.stroke();
        }
    }

    function loop() {
        let now=performance.now();
        fpsRolling=(fpsRolling*0.9)+((1000/Math.max(1,now-lastFrameTime))*0.1);
        lastFrameTime=now;
        const perfEl=document.getElementById('v1-perf-indicator');
        if(fpsRolling<30){CHUNK_SIZE=Math.max(50,CHUNK_SIZE-5);perfEl.textContent='Compute: Throttled';perfEl.style.color='#f87171';}
        else if(fpsRolling>55){CHUNK_SIZE=Math.min(800,CHUNK_SIZE+2);perfEl.textContent='Compute: Unleashed';perfEl.style.color='#34d399';}

        for(let c=0;c<CHUNK_SIZE;c++){
            balls.forEach((b,i)=>b.update(shadowBalls[i]));
            shadowBalls.forEach(b=>b.update(null));
            applyExclusionPrinciple();
            checkInversion();
            ticks++;
        }
        draw();

        if(sharedDbConnected && ticks>0 && ticks%10000===0 && chaosRatio<8.0){
            let currentEvolvedHash=generateHash();
            if(!sharedKnownHashes.has(currentEvolvedHash)){
                sharedKnownHashes.add(currentEvolvedHash);
                sharedSupabase.from('museum').upsert({
                    hash:currentEvolvedHash,
                    chaos_ratio:chaosRatio.toFixed(2),
                    tick_detected:ticks,
                    inversions,
                    version:'v1'
                }).catch(e=>console.error(e));
            }
        }
        // Publish to genesis_brain so spectral_link / deep_learning can render sim3 state
        gbWriteSim3({
            balls: balls.slice(0, 49).map(b => ({
                x: (CENTER_X + b.x * baseScale) / width,   // normalized 0-1
                y: (CENTER_Y + b.y * baseScale) / height,
                vx: b.vx, vy: b.vy,
                winding: b.winding,
                color: b.color,
                type: b.type,
                groupId: b.groupId
            })),
            chaos_ratio: chaosRatio,
            inversions: inversions,
            ticks: ticks,
            geo: currentGeoName,
            sim_mode: simMode,
            version: 'v1'
        });
        v1Loop = requestAnimationFrame(loop);
    }

    // UI
    const v1Title = document.getElementById('v1-engine-title');
    const v1TabPlat = document.getElementById('v1-tab-platonic');
    const v1TabDisc = document.getElementById('v1-tab-discovery');
    const v1GeoCont = document.getElementById('v1-geo-selector-container');

    v1TabPlat.onclick = () => {
        simMode='platonic';
        v1Title.textContent='Platonic Boundary Sim';
        v1Title.style.background='linear-gradient(to right,#38bdf8,#6366f1)';
        v1TabPlat.style.cssText='padding:8px 16px;border-radius:8px;color:#38bdf8;font-weight:700;border-bottom:2px solid #38bdf8;cursor:pointer;background:none;';
        v1TabDisc.style.cssText='padding:8px 16px;border-radius:8px;color:#94a3b8;cursor:pointer;background:none;border:none;';
        v1GeoCont.style.display='flex';
        initBalls();
    };
    v1TabDisc.onclick = () => {
        simMode='discovery';
        v1Title.textContent='Boundary Discovery Engine';
        v1Title.style.background='linear-gradient(to right,#c084fc,#ec4899)';
        v1TabDisc.style.cssText='padding:8px 16px;border-radius:8px;color:#c084fc;font-weight:700;border-bottom:2px solid #c084fc;cursor:pointer;background:none;';
        v1TabPlat.style.cssText='padding:8px 16px;border-radius:8px;color:#94a3b8;cursor:pointer;background:none;border:none;';
        v1GeoCont.style.display='none';
        initBalls();
    };
    document.getElementById('v1-geo-select').onchange = (e) => {
        currentGeoName=e.target.value; activeGeo=geometries[currentGeoName]; initBalls();
    };
    window.addEventListener('resize', () => { if(activeVersion==='v1') resizeCanvas(); });

    resizeCanvas();
    initBalls();
    loop();
}
</script>


<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     V2 ENGINE ‚Äî ENHANCED, ISOLATED
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script>
function initV2() {
    const colors = ['#ef4444','#f97316','#eab308','#22c55e','#3b82f6','#4f46e5','#a855f7'];
    const ST_H = 5;
    const ZETA_VOID_LIMIT = 2000;

    const canvas = document.getElementById('v2-canvas');
    const ctx = canvas.getContext('2d');
    let width, height, CENTER_X, CENTER_Y, baseScale = 1;
    let bgPattern, fgPatterns = [];

    // Deep scan system
    let scanLevel = 1;
    let scanParentHash = null;
    const SCAN_CONFIGS = [
        null,
        { exclusionDist:25, trailLen:50, label:'1', color:'#38bdf8' },
        { exclusionDist:10, trailLen:25, label:'2', color:'#f59e0b' },
        { exclusionDist:4,  trailLen:12, label:'3', color:'#a855f7' },
    ];
    let wallHeat = new Array(8).fill(0);
    let wallHeatMax = 1;
    let lastDiscoveryFlash = 0;
    let museumCount = 0;

    function getScanConfig() { return SCAN_CONFIGS[Math.min(scanLevel,3)]; }

    function initPatterns() {
        let bgCanv=document.createElement('canvas');
        bgCanv.width=1;bgCanv.height=ST_H*7;
        let bCtx=bgCanv.getContext('2d');
        colors.forEach((c,i)=>{bCtx.fillStyle=c;bCtx.fillRect(0,i*ST_H,1,ST_H);});
        bgPattern=ctx.createPattern(bgCanv,'repeat');
        fgPatterns=colors.map((c,i)=>{
            let fc=document.createElement('canvas');fc.width=1;fc.height=ST_H*7;
            let fCtx=fc.getContext('2d');fCtx.fillStyle=c;fCtx.fillRect(0,i*ST_H,1,ST_H);
            return ctx.createPattern(fc,'repeat');
        });
    }

    function resizeCanvas() {
        width=window.innerWidth;height=window.innerHeight;
        canvas.width=width;canvas.height=height;
        CENTER_X=width/2;CENTER_Y=height/2;
        baseScale=Math.min(width,height)/800;
        initPatterns();
    }

    let simMode='platonic', currentGeoName='Square';
    let ticks=0, inversions=0, chaosRatio=0.0;
    let CHUNK_SIZE=300, lastFrameTime=performance.now(), fpsRolling=60;
    let discoveryBounds={minX:-150,maxX:150,minY:-150,maxY:150};

    const geometries={
        'Square':  {type:'poly',basePoints:[[-150,-150],[150,-150],[150,150],[-150,150]],scale:1},
        'Triangle':{type:'poly',basePoints:[[0,-180],[156,90],[-156,90]],scale:1},
        'Hexagon': {type:'poly',basePoints:[],scale:1},
        'Octagon': {type:'poly',basePoints:[],scale:1},
        'Circle':  {type:'circle',baseRadius:150,scale:1}
    };
    for(let i=0;i<6;i++) geometries['Hexagon'].basePoints.push([Math.cos(i*Math.PI/3-Math.PI/6)*165,Math.sin(i*Math.PI/3-Math.PI/6)*165]);
    for(let i=0;i<8;i++) geometries['Octagon'].basePoints.push([Math.cos(i*Math.PI/4-Math.PI/8)*160,Math.sin(i*Math.PI/4-Math.PI/8)*160]);
    let activeGeo=geometries['Square'];

    function getScaledPoints(){
        if(activeGeo.type!=='poly') return [];
        return activeGeo.basePoints.map(p=>[p[0]*activeGeo.scale,p[1]*activeGeo.scale]);
    }

    class Ball {
        constructor(groupId,isShadow=false){
            this.groupId=groupId;this.color=colors[groupId];
            this.isShadow=isShadow;this.type=Math.random()>0.5?'smith':'blade';
            this.reset();
        }
        reset(){
            this.x=(Math.random()*80-40);this.y=(Math.random()*80-40);
            let speed=this.type==='blade'?2.5:1.2;
            let angle=Math.random()*Math.PI*2;
            this.vx=Math.cos(angle)*speed;this.vy=Math.sin(angle)*speed;
            this.winding=0;this.ticksSinceHit=0;
            this.path=[];this.lastAngle=undefined;this.glowIntensity=0;
        }
        update(shadowBall){
            this.x+=this.vx;this.y+=this.vy;this.ticksSinceHit++;
            this.glowIntensity*=0.92;
            if(!this.isShadow&&shadowBall){
                let dx=this.x-shadowBall.x,dy=this.y-shadowBall.y;
                chaosRatio=(chaosRatio*0.999)+(Math.sqrt(dx*dx+dy*dy)*0.001);
            }
            const cfg=getScanConfig();
            if(!this.isShadow&&ticks%5===0){
                this.path.push({x:this.x,y:this.y});
                if(this.path.length>cfg.trailLen) this.path.shift();
            }
            let angle=Math.atan2(this.y,this.x);
            if(this.lastAngle!==undefined){
                let da=angle-this.lastAngle;
                if(da>Math.PI)da-=2*Math.PI;if(da<-Math.PI)da+=2*Math.PI;
                this.winding+=da/(2*Math.PI);
            }
            this.lastAngle=angle;
            this.checkBoundaries();
            if(this.ticksSinceHit>ZETA_VOID_LIMIT){this.x*=0.1;this.y*=0.1;this.vx*=-1;this.vy*=-1;this.ticksSinceHit=0;}
        }
        checkBoundaries(){
            let hit=false,wallIdx=-1;
            if(simMode==='discovery'){
                if(this.x<discoveryBounds.minX||this.x>discoveryBounds.maxX){
                    wallIdx=this.x<discoveryBounds.minX?3:1;
                    if(this.type==='blade'){discoveryBounds.minX-=0.05;discoveryBounds.maxX+=0.05;}
                    this.vx*=-1;this.x=this.x<discoveryBounds.minX?discoveryBounds.minX:discoveryBounds.maxX;hit=true;
                }
                if(this.y<discoveryBounds.minY||this.y>discoveryBounds.maxY){
                    wallIdx=this.y<discoveryBounds.minY?0:2;
                    if(this.type==='blade'){discoveryBounds.minY-=0.05;discoveryBounds.maxY+=0.05;}
                    this.vy*=-1;this.y=this.y<discoveryBounds.minY?discoveryBounds.minY:discoveryBounds.maxY;hit=true;
                }
            } else {
                if(activeGeo.type==='circle'){
                    let r=activeGeo.baseRadius*activeGeo.scale;
                    if(this.x*this.x+this.y*this.y>r*r){
                        if(this.type==='blade') activeGeo.scale+=0.0002;
                        let dist=Math.sqrt(this.x*this.x+this.y*this.y);
                        let nx=this.x/dist,ny=this.y/dist,dot=this.vx*nx+this.vy*ny;
                        if(dot>0){this.vx-=2*dot*nx;this.vy-=2*dot*ny;this.x=nx*r;this.y=ny*r;hit=true;wallIdx=0;}
                    }
                } else {
                    let pts=getScaledPoints();
                    for(let i=0;i<pts.length;i++){
                        let p1=pts[i],p2=pts[(i+1)%pts.length];
                        let nx=-(p2[1]-p1[1]),ny=p2[0]-p1[0];
                        let len=Math.sqrt(nx*nx+ny*ny);nx/=len;ny/=len;
                        if(nx*(-p1[0])+ny*(-p1[1])<0){nx=-nx;ny=-ny;}
                        let d=(this.x-p1[0])*nx+(this.y-p1[1])*ny;
                        if(d<0){
                            if(this.type==='blade') activeGeo.scale+=0.0002;
                            let dot=this.vx*(-nx)+this.vy*(-ny);
                            if(dot>0){this.vx-=2*dot*(-nx);this.vy-=2*dot*(-ny);this.x-=d*nx;this.y-=d*ny;hit=true;wallIdx=i;}
                        }
                    }
                }
            }
            if(hit){
                this.ticksSinceHit=0;
                this.glowIntensity=Math.min(1,this.glowIntensity+0.6);
                if(wallIdx>=0){if(!wallHeat[wallIdx])wallHeat[wallIdx]=0;wallHeat[wallIdx]++;wallHeatMax=Math.max(wallHeatMax,wallHeat[wallIdx]);}
            }
        }
    }

    let balls=[],shadowBalls=[];

    function generateHash(){
        const cfg=getScanConfig();
        let str=balls.map(b=>`${b.type}_${b.vx.toFixed(1)}_${b.vy.toFixed(1)}`).join('|');
        let hash=0;
        for(let i=0;i<str.length;i++) hash=Math.imul(31,hash)+str.charCodeAt(i)|0;
        let prefix=simMode==='discovery'
            ?`Disc_W${Math.floor(discoveryBounds.maxX-discoveryBounds.minX)}_Ex${cfg.exclusionDist}_v2`
            :`${currentGeoName}_Ex${cfg.exclusionDist}_v2`;
        return `${prefix}_${Math.abs(hash).toString(16)}`;
    }

    function initBalls(){
        balls=[];shadowBalls=[];
        wallHeat=new Array(8).fill(0);wallHeatMax=1;
        discoveryBounds={minX:-150,maxX:150,minY:-150,maxY:150};
        activeGeo.scale=1.0;ticks=0;chaosRatio=0;inversions=0;
        for(let g=0;g<7;g++){
            for(let i=0;i<7;i++){
                let b=new Ball(g,false);balls.push(b);
                let s=new Ball(g,true);s.x=b.x;s.y=b.y;s.vx=b.vx+1e-7;s.vy=b.vy+1e-7;
                shadowBalls.push(s);
            }
        }
        if(sharedKnownHashes.has(generateHash())) initBalls();
    }

    function triggerDeepScan(parentHash){
        if(scanLevel>=3){scanLevel=1;scanParentHash=null;document.getElementById('v2-deep-badge').classList.remove('active');}
        else{scanLevel++;scanParentHash=parentHash;document.getElementById('v2-deep-badge').classList.add('active');}
        document.getElementById('v2-stat-scan').textContent=scanLevel;
        initBalls();
    }

    function applyExclusionPrinciple(){
        const cfg=getScanConfig();
        for(let i=0;i<balls.length;i++){
            for(let j=i+1;j<balls.length;j++){
                let dx=balls[i].x-balls[j].x,dy=balls[i].y-balls[j].y;
                if(dx*dx+dy*dy<cfg.exclusionDist){
                    let b1=balls[i],b2=balls[j];
                    b1.glowIntensity=Math.min(1,b1.glowIntensity+0.4);
                    b2.glowIntensity=Math.min(1,b2.glowIntensity+0.4);
                    if(Math.abs(b1.winding)<0.1){b1.vx=(Math.random()-0.5)*15;b1.vy=(Math.random()-0.5)*15;}
                    if(Math.abs(b1.winding)>Math.abs(b2.winding)){b2.vx*=-1.08;b2.vy*=-1.08;}
                    else{b1.vx*=-1.08;b1.vy*=-1.08;}
                }
            }
        }
    }

    function checkInversion(){
        if(simMode==='platonic'&&activeGeo.scale>4.5){
            inversions++;activeGeo.scale=0.5;
            balls.forEach(b=>{b.x*=0.1;b.y*=0.1;b.vx*=-1;b.vy*=-1;});
        } else if(simMode==='discovery'&&(discoveryBounds.maxX-discoveryBounds.minX>760)){
            inversions++;discoveryBounds={minX:-50,maxX:50,minY:-50,maxY:50};
            balls.forEach(b=>{b.x*=0.1;b.y*=0.1;b.vx*=-1;b.vy*=-1;});
        }
        document.getElementById('v2-stat-inv').textContent=inversions;
    }

    let toastTimeout=null;
    function showToast(icon,title,sub){
        const toast=document.getElementById('v2-museum-toast');
        document.getElementById('v2-toast-icon').textContent=icon;
        document.getElementById('v2-toast-title').textContent=title;
        document.getElementById('v2-toast-sub').textContent=sub;
        toast.classList.add('show');
        clearTimeout(toastTimeout);
        toastTimeout=setTimeout(()=>toast.classList.remove('show'),3500);
    }

    function draw(){
        const now=performance.now();
        ctx.clearRect(0,0,width,height);
        ctx.fillStyle=bgPattern;ctx.fillRect(0,0,width,height);

        // Scan level tint
        if(scanLevel>1){
            ctx.fillStyle=scanLevel===2?'rgba(245,158,11,0.06)':'rgba(168,85,247,0.08)';
            ctx.fillRect(0,0,width,height);
        }
        // Chaos atmosphere
        if(chaosRatio>5){
            let intensity=Math.min(1,(chaosRatio-5)/10)*0.15;
            ctx.fillStyle=`rgba(239,68,68,${intensity})`;ctx.fillRect(0,0,width,height);
        }

        // Mask
        ctx.fillStyle='rgba(2,6,23,0.72)';ctx.beginPath();ctx.rect(0,0,width,height);
        if(simMode==='discovery'){
            ctx.rect(CENTER_X+discoveryBounds.minX*baseScale,CENTER_Y+discoveryBounds.minY*baseScale,(discoveryBounds.maxX-discoveryBounds.minX)*baseScale,(discoveryBounds.maxY-discoveryBounds.minY)*baseScale);
        } else if(activeGeo.type==='circle'){
            ctx.arc(CENTER_X,CENTER_Y,activeGeo.baseRadius*activeGeo.scale*baseScale,0,Math.PI*2,true);
        } else {
            let pts=getScaledPoints();ctx.moveTo(CENTER_X+pts[0][0]*baseScale,CENTER_Y+pts[0][1]*baseScale);
            for(let i=pts.length-1;i>=0;i--) ctx.lineTo(CENTER_X+pts[i][0]*baseScale,CENTER_Y+pts[i][1]*baseScale);
        }
        ctx.fill('evenodd');

        // Ruliad graph
        ctx.lineWidth=1.5;ctx.globalCompositeOperation='hard-light';
        let maxDist=(simMode==='discovery'?150:150*activeGeo.scale)*baseScale;
        for(let i=0;i<balls.length;i++){
            for(let j=i+1;j<balls.length;j++){
                let dx=balls[i].x*baseScale-balls[j].x*baseScale;
                let dy=balls[i].y*baseScale-balls[j].y*baseScale;
                if(Math.abs(dx)>maxDist||Math.abs(dy)>maxDist) continue;
                let dist=Math.sqrt(dx*dx+dy*dy);
                if(dist<maxDist){
                    ctx.beginPath();
                    ctx.moveTo(CENTER_X+balls[i].x*baseScale,CENTER_Y+balls[i].y*baseScale);
                    let warpX=(balls[i].vx+balls[j].vx)*10*baseScale;
                    let warpY=(balls[i].vy+balls[j].vy)*10*baseScale;
                    ctx.bezierCurveTo(CENTER_X+balls[i].x*baseScale+warpX,CENTER_Y+balls[i].y*baseScale-warpY,CENTER_X+balls[j].x*baseScale-warpX,CENTER_Y+balls[j].y*baseScale+warpY,CENTER_X+balls[j].x*baseScale,CENTER_Y+balls[j].y*baseScale);
                    let opacity=(1-dist/maxDist)*0.8;
                    let grad=ctx.createLinearGradient(CENTER_X+balls[i].x*baseScale,CENTER_Y+balls[i].y*baseScale,CENTER_X+balls[j].x*baseScale,CENTER_Y+balls[j].y*baseScale);
                    grad.addColorStop(0,balls[i].color+Math.floor(opacity*255).toString(16).padStart(2,'0'));
                    grad.addColorStop(1,balls[j].color+Math.floor(opacity*255).toString(16).padStart(2,'0'));
                    ctx.strokeStyle=grad;ctx.stroke();
                }
            }
        }
        ctx.globalCompositeOperation='source-over';

        // Trails + balls with winding visuals
        for(let g=0;g<7;g++){
            let groupBalls=balls.filter(b=>b.groupId===g);
            groupBalls.forEach(b=>{
                if(b.path.length>1){
                    let windingBoost=Math.min(1,Math.abs(b.winding)/5);
                    ctx.beginPath();
                    ctx.moveTo(CENTER_X+b.path[0].x*baseScale,CENTER_Y+b.path[0].y*baseScale);
                    for(let i=1;i<b.path.length;i++){
                        let xc=CENTER_X+(b.path[i-1].x+b.path[i].x)/2*baseScale;
                        let yc=CENTER_Y+(b.path[i-1].y+b.path[i].y)/2*baseScale;
                        ctx.quadraticCurveTo(CENTER_X+b.path[i-1].x*baseScale,CENTER_Y+b.path[i-1].y*baseScale,xc,yc);
                    }
                    ctx.lineTo(CENTER_X+b.x*baseScale,CENTER_Y+b.y*baseScale);
                    ctx.lineWidth=b.type==='smith'?3+windingBoost*2:1.5+windingBoost;
                    ctx.globalAlpha=0.35+windingBoost*0.45;
                    ctx.strokeStyle='#94a3b8';ctx.stroke();
                    if(fgPatterns[g]){ctx.strokeStyle=fgPatterns[g];ctx.stroke();}
                    ctx.globalAlpha=1;
                }
            });
            groupBalls.forEach(b=>{
                let windingBoost=Math.min(1,Math.abs(b.winding)/5);
                let r=(b.type==='smith'?8:5)*baseScale;
                let glowAmt=Math.max(windingBoost*0.6,b.glowIntensity);
                if(glowAmt>0.05){
                    ctx.beginPath();ctx.arc(CENTER_X+b.x*baseScale,CENTER_Y+b.y*baseScale,r*(1.8+glowAmt*2),0,Math.PI*2);
                    ctx.fillStyle=b.color+Math.floor(glowAmt*80).toString(16).padStart(2,'0');ctx.fill();
                }
                ctx.beginPath();ctx.arc(CENTER_X+b.x*baseScale,CENTER_Y+b.y*baseScale,r*(1+windingBoost*0.4),0,Math.PI*2);
                ctx.fillStyle='#94a3b8';ctx.fill();
                if(fgPatterns[g]){ctx.fillStyle=fgPatterns[g];ctx.fill();}
                if(b.type==='smith'&&Math.abs(b.winding)>1){
                    ctx.beginPath();ctx.arc(CENTER_X+b.x*baseScale,CENTER_Y+b.y*baseScale,r*1.6,0,Math.PI*2);
                    ctx.strokeStyle=b.color+'aa';ctx.lineWidth=1.5;ctx.stroke();
                }
            });
        }

        // Boundary with heat
        drawBoundaryWithHeat();

        // Discovery flash
        if(lastDiscoveryFlash>0){
            let elapsed=now-lastDiscoveryFlash;
            if(elapsed<800){
                let t=elapsed/800,alpha=(1-t)*0.35;
                ctx.fillStyle=`rgba(168,85,247,${alpha})`;ctx.fillRect(0,0,width,height);
                ctx.globalAlpha=(1-t);drawBoundaryStroke('#a855f7',6);ctx.globalAlpha=1;
            } else {lastDiscoveryFlash=0;}
        }

        // Stats
        document.getElementById('v2-stat-chaos').textContent=chaosRatio.toFixed(2);
        document.getElementById('v2-stat-chaos').style.color=chaosRatio>8?'#f87171':chaosRatio>4?'#f59e0b':'#34d399';
    }

    function drawBoundaryWithHeat(){
        if(simMode==='discovery'){
            const walls=[
                {x1:CENTER_X+discoveryBounds.minX*baseScale,y1:CENTER_Y+discoveryBounds.minY*baseScale,x2:CENTER_X+discoveryBounds.maxX*baseScale,y2:CENTER_Y+discoveryBounds.minY*baseScale,idx:0},
                {x1:CENTER_X+discoveryBounds.maxX*baseScale,y1:CENTER_Y+discoveryBounds.minY*baseScale,x2:CENTER_X+discoveryBounds.maxX*baseScale,y2:CENTER_Y+discoveryBounds.maxY*baseScale,idx:1},
                {x1:CENTER_X+discoveryBounds.maxX*baseScale,y1:CENTER_Y+discoveryBounds.maxY*baseScale,x2:CENTER_X+discoveryBounds.minX*baseScale,y2:CENTER_Y+discoveryBounds.maxY*baseScale,idx:2},
                {x1:CENTER_X+discoveryBounds.minX*baseScale,y1:CENTER_Y+discoveryBounds.maxY*baseScale,x2:CENTER_X+discoveryBounds.minX*baseScale,y2:CENTER_Y+discoveryBounds.minY*baseScale,idx:3}
            ];
            walls.forEach(w=>{
                let heat=(wallHeat[w.idx]||0)/wallHeatMax;
                ctx.beginPath();ctx.moveTo(w.x1,w.y1);ctx.lineTo(w.x2,w.y2);
                ctx.strokeStyle='#334155';ctx.lineWidth=2;ctx.stroke();
                if(heat>0.05){
                    let heatColor=`rgba(${Math.floor(59+heat*196)},${Math.floor(130-heat*130)},${Math.floor(246-heat*246)},${heat*0.9})`;
                    ctx.beginPath();ctx.moveTo(w.x1,w.y1);ctx.lineTo(w.x2,w.y2);
                    ctx.strokeStyle=heatColor;ctx.lineWidth=2+heat*6;
                    ctx.shadowColor=heatColor;ctx.shadowBlur=heat*20;ctx.stroke();ctx.shadowBlur=0;
                }
            });
        } else if(activeGeo.type==='circle'){
            let heat=(wallHeat[0]||0)/wallHeatMax;
            ctx.beginPath();ctx.arc(CENTER_X,CENTER_Y,activeGeo.baseRadius*activeGeo.scale*baseScale,0,Math.PI*2);
            ctx.strokeStyle='#334155';ctx.lineWidth=3;ctx.stroke();
            if(heat>0.05){
                let heatColor=`rgba(${Math.floor(59+heat*196)},${Math.floor(130-heat*130)},${Math.floor(246-heat*246)},${heat*0.8})`;
                ctx.strokeStyle=heatColor;ctx.lineWidth=3+heat*8;ctx.shadowColor=heatColor;ctx.shadowBlur=heat*25;ctx.stroke();ctx.shadowBlur=0;
            }
        } else {
            let pts=getScaledPoints();
            for(let i=0;i<pts.length;i++){
                let p1=pts[i],p2=pts[(i+1)%pts.length];
                let heat=(wallHeat[i]||0)/wallHeatMax;
                ctx.beginPath();ctx.moveTo(CENTER_X+p1[0]*baseScale,CENTER_Y+p1[1]*baseScale);ctx.lineTo(CENTER_X+p2[0]*baseScale,CENTER_Y+p2[1]*baseScale);
                ctx.strokeStyle='#334155';ctx.lineWidth=3;ctx.stroke();
                if(heat>0.05){
                    let heatColor=`rgba(${Math.floor(59+heat*196)},${Math.floor(130-heat*130)},${Math.floor(246-heat*246)},${heat*0.9})`;
                    ctx.strokeStyle=heatColor;ctx.lineWidth=3+heat*8;ctx.shadowColor=heatColor;ctx.shadowBlur=heat*20;ctx.stroke();ctx.shadowBlur=0;
                }
            }
        }
    }

    function drawBoundaryStroke(color,lineWidth){
        ctx.strokeStyle=color;ctx.lineWidth=lineWidth;
        if(simMode==='discovery'){
            ctx.strokeRect(CENTER_X+discoveryBounds.minX*baseScale,CENTER_Y+discoveryBounds.minY*baseScale,(discoveryBounds.maxX-discoveryBounds.minX)*baseScale,(discoveryBounds.maxY-discoveryBounds.minY)*baseScale);
        } else if(activeGeo.type==='circle'){
            ctx.beginPath();ctx.arc(CENTER_X,CENTER_Y,activeGeo.baseRadius*activeGeo.scale*baseScale,0,Math.PI*2);ctx.stroke();
        } else {
            let pts=getScaledPoints();
            ctx.beginPath();ctx.moveTo(CENTER_X+pts[0][0]*baseScale,CENTER_Y+pts[0][1]*baseScale);
            for(let i=1;i<pts.length;i++) ctx.lineTo(CENTER_X+pts[i][0]*baseScale,CENTER_Y+pts[i][1]*baseScale);
            ctx.closePath();ctx.stroke();
        }
    }

    function loop(){
        let now=performance.now();
        fpsRolling=(fpsRolling*0.9)+((1000/Math.max(1,now-lastFrameTime))*0.1);
        lastFrameTime=now;
        const perfEl=document.getElementById('v2-perf-indicator');
        if(fpsRolling<30){CHUNK_SIZE=Math.max(50,CHUNK_SIZE-5);perfEl.textContent='Compute: Throttled';perfEl.style.color='#f87171';}
        else if(fpsRolling>55){CHUNK_SIZE=Math.min(800,CHUNK_SIZE+2);perfEl.textContent='Compute: Unleashed';perfEl.style.color='#34d399';}

        for(let c=0;c<CHUNK_SIZE;c++){
            balls.forEach((b,i)=>b.update(shadowBalls[i]));
            shadowBalls.forEach(b=>b.update(null));
            applyExclusionPrinciple();
            checkInversion();
            ticks++;
        }
        draw();

        if(sharedDbConnected&&ticks>0&&ticks%10000===0&&chaosRatio<8.0){
            let hash=generateHash();
            if(!sharedKnownHashes.has(hash)){
                sharedKnownHashes.add(hash);
                museumCount++;
                document.getElementById('v2-stat-museum').textContent=museumCount;
                lastDiscoveryFlash=performance.now();
                showToast(scanLevel>1?'üî¨':'üèõÔ∏è',scanLevel>1?`Deep Scan Lv${scanLevel} Discovery`:'New Structure Found',hash.substring(0,32)+'...');
                sharedSupabase.from('museum').upsert({
                    hash,
                    chaos_ratio:chaosRatio.toFixed(2),
                    tick_detected:ticks,
                    inversions,
                    version:'v2',
                    scan_level:scanLevel,
                    exclusion_dist:getScanConfig().exclusionDist,
                    trail_len:getScanConfig().trailLen,
                    parent_hash:scanParentHash||null
                }).catch(e=>console.error(e));
                setTimeout(()=>triggerDeepScan(hash),200);
            }
        }
        // Publish to genesis_brain ‚Äî richer data from V2
        gbWriteSim3({
            balls: balls.slice(0, 49).map(b => ({
                x: (CENTER_X + b.x * baseScale) / width,
                y: (CENTER_Y + b.y * baseScale) / height,
                vx: b.vx, vy: b.vy,
                winding: b.winding,
                color: b.color,
                type: b.type,
                groupId: b.groupId,
                glow: b.glowIntensity
            })),
            chaos_ratio: chaosRatio,
            inversions: inversions,
            ticks: ticks,
            geo: currentGeoName,
            sim_mode: simMode,
            scan_level: scanLevel,
            wall_heat: wallHeat,
            wall_heat_max: wallHeatMax,
            version: 'v2'
        });
        v2Loop=requestAnimationFrame(loop);
    }

    // UI
    const v2Title=document.getElementById('v2-engine-title');
    const v2TabPlat=document.getElementById('v2-tab-platonic');
    const v2TabDisc=document.getElementById('v2-tab-discovery');
    const v2GeoCont=document.getElementById('v2-geo-selector-container');

    v2TabPlat.onclick=()=>{
        simMode='platonic';scanLevel=1;scanParentHash=null;
        document.getElementById('v2-deep-badge').classList.remove('active');
        document.getElementById('v2-stat-scan').textContent='1';
        v2Title.textContent='Platonic Boundary Sim';
        v2Title.style.background='linear-gradient(to right,#38bdf8,#6366f1)';
        v2TabPlat.style.cssText='padding:8px 16px;border-radius:8px;color:#38bdf8;font-weight:700;border-bottom:2px solid #38bdf8;cursor:pointer;background:none;';
        v2TabDisc.style.cssText='padding:8px 16px;border-radius:8px;color:#94a3b8;cursor:pointer;background:none;border:none;';
        v2GeoCont.style.display='flex';initBalls();
    };
    v2TabDisc.onclick=()=>{
        simMode='discovery';scanLevel=1;scanParentHash=null;
        document.getElementById('v2-deep-badge').classList.remove('active');
        document.getElementById('v2-stat-scan').textContent='1';
        v2Title.textContent='Boundary Discovery Engine';
        v2Title.style.background='linear-gradient(to right,#c084fc,#ec4899)';
        v2TabDisc.style.cssText='padding:8px 16px;border-radius:8px;color:#c084fc;font-weight:700;border-bottom:2px solid #c084fc;cursor:pointer;background:none;';
        v2TabPlat.style.cssText='padding:8px 16px;border-radius:8px;color:#94a3b8;cursor:pointer;background:none;border:none;';
        v2GeoCont.style.display='none';initBalls();
    };
    document.getElementById('v2-geo-select').onchange=(e)=>{
        currentGeoName=e.target.value;activeGeo=geometries[currentGeoName];
        scanLevel=1;scanParentHash=null;
        document.getElementById('v2-deep-badge').classList.remove('active');
        initBalls();
    };
    window.addEventListener('resize',()=>{if(activeVersion==='v2') resizeCanvas();});

    resizeCanvas();
    initBalls();
    loop();
}
</script>

</body>
</html>