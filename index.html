<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sim3colts - Unified Learning Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- SUPABASE CLIENT -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; }
        
        .glass-panel {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        
        @keyframes shimmer { 100% { transform: translateX(100%); } }
        .animate-shimmer { animation: shimmer 2s infinite; }
    </style>
</head>
<body class="text-slate-100 h-screen w-screen font-sans">
    
    <!-- FULLSCREEN COMPOSITE SIMULATION CANVAS -->
    <canvas id="bg-canvas" class="fixed inset-0 w-full h-full z-0"></canvas>

    <!-- MINIMALIST UI OVERLAY -->
    <div class="absolute inset-0 z-10 flex flex-col p-3 md:p-6 pointer-events-none">
        
        <!-- Header -->
        <div class="w-full max-w-7xl mx-auto shrink-0 pointer-events-auto">
            <div class="glass-panel rounded-2xl p-4 md:p-5 flex justify-between items-center border-t-2 border-t-sky-500/50">
                <div>
                    <h1 id="engine-title" class="text-xl md:text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-sky-400 to-indigo-500">Platonic Boundary Sim</h1>
                    <div id="geo-selector-container" class="flex items-center gap-2 mt-2">
                        <span class="text-slate-400 text-[10px] uppercase tracking-widest font-bold">Domain:</span>
                        <select id="geo-select" class="bg-slate-900/80 text-sky-400 border border-slate-700 px-2 py-0.5 rounded text-[10px] font-mono outline-none cursor-pointer">
                            <option value="Square">Square</option>
                            <option value="Triangle">Equilateral Triangle</option>
                            <option value="Hexagon">Regular Hexagon</option>
                            <option value="Octagon">Regular Octagon</option>
                            <option value="Circle">Circular Domain</option>
                        </select>
                    </div>
                </div>
                
                <div class="flex gap-4 items-center">
                    <span id="perf-indicator" class="text-[10px] font-mono text-emerald-400 uppercase font-bold hidden md:block">Scaling...</span>
                    <a href="https://buymeacoffee.com/brandonkennedy" target="_blank" class="hover:scale-105 transition-transform duration-200">
                        <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 32px !important;width: 115px !important;" >
                    </a>
                </div>
            </div>

            <!-- NAVIGATION TABS -->
            <div class="mt-3 flex flex-wrap gap-3 text-[10px] md:text-xs font-mono tracking-wide">
                <button id="tab-platonic" class="glass-panel px-3 py-1.5 rounded-lg text-sky-400 font-bold border-b-2 border-b-sky-400 transition">
                    [1] Platonic Mode
                </button>
                <button id="tab-discovery" class="glass-panel px-3 py-1.5 rounded-lg text-slate-400 hover:text-purple-300 transition">
                    [2] Discovery Mode
                </button>
            </div>
        </div>

    </div>

    <script type="module">
        // --- 1. SUPABASE INTEGRATION ---
        const SUPABASE_URL = 'https://xoolmbmnzbsvcqeyqvyi.supabase.co'; 
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inhvb2xtYm1uemJzdmNxZXlxdnlpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE0NDMwNDQsImV4cCI6MjA4NzAxOTA0NH0.ebTwMZ_byU6EXtuR0jynct64QO5ornQrCwElQ5b9TxQ';

        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let dbConnected = false;
        let museumTableExists = true;

        // --- 2. CANVAS & RESPONSIVE SETUP ---
        const canvas = document.getElementById('bg-canvas');
        const ctx = canvas.getContext('2d');
        let width, height, CENTER_X, CENTER_Y;
        let baseScale = 1;

        const ST_H = 5; 
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#4f46e5', '#a855f7'];
        let bgPattern, fgPatterns = [];

        function initPatterns() {
            let bgCanv = document.createElement('canvas');
            bgCanv.width = 1; bgCanv.height = ST_H * 7;
            let bCtx = bgCanv.getContext('2d');
            colors.forEach((c, i) => {
                bCtx.fillStyle = c;
                bCtx.fillRect(0, i * ST_H, 1, ST_H);
            });
            bgPattern = ctx.createPattern(bgCanv, 'repeat');
            fgPatterns = colors.map((c, i) => {
                let fgCanv = document.createElement('canvas');
                fgCanv.width = 1; fgCanv.height = ST_H * 7;
                let fCtx = fgCanv.getContext('2d');
                fCtx.fillStyle = c;
                fCtx.fillRect(0, i * ST_H, 1, ST_H);
                return ctx.createPattern(fgCanv, 'repeat');
            });
        }

        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            CENTER_X = width / 2;
            CENTER_Y = height / 2;
            baseScale = Math.min(width, height) / 800; 
            initPatterns(); 
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); 

        // --- 3. STATE & GEOMETRIES ---
        let simMode = 'platonic'; // 'platonic' or 'discovery'
        let CHUNK_SIZE = 300; 
        const ZETA_VOID_LIMIT = 2000; 
        let isRunning = true;
        let ticks = 0;
        let inversions = 0;
        let chaosRatio = 0.0;
        let knownHashes = new Set();
        let currentConfigHash = "";
        let lastFrameTime = performance.now();
        let fpsRolling = 60;

        let discoveryBounds = { minX: -100, maxX: 100, minY: -100, maxY: 100 };
        const geometries = {
            'Square': { type: 'poly', basePoints: [[-150,-150], [150,-150], [150,150], [-150,150]], scale: 1 },
            'Triangle': { type: 'poly', basePoints: [[0,-180], [156,90], [-156,90]], scale: 1 },
            'Hexagon': { type: 'poly', basePoints: [], scale: 1 },
            'Octagon': { type: 'poly', basePoints: [], scale: 1 },
            'Circle': { type: 'circle', baseRadius: 150, scale: 1 }
        };

        for(let i=0; i<6; i++) geometries['Hexagon'].basePoints.push([Math.cos(i * Math.PI / 3 - Math.PI/6)*165, Math.sin(i * Math.PI / 3 - Math.PI/6)*165]);
        for(let i=0; i<8; i++) geometries['Octagon'].basePoints.push([Math.cos(i * Math.PI / 4 - Math.PI/8)*160, Math.sin(i * Math.PI / 4 - Math.PI/8)*160]);

        let activeGeo = geometries['Square'];

        function getScaledPoints() {
            if (activeGeo.type !== 'poly') return [];
            return activeGeo.basePoints.map(p => [p[0] * activeGeo.scale, p[1] * activeGeo.scale]);
        }

        // --- 4. PHYSICS ---
        class Ball {
            constructor(groupId, isShadow = false) {
                this.groupId = groupId;
                this.color = colors[groupId];
                this.isShadow = isShadow;
                this.type = Math.random() > 0.5 ? 'smith' : 'blade';
                this.reset();
            }
            reset() {
                this.x = (Math.random() * 80 - 40);
                this.y = (Math.random() * 80 - 40);
                let speed = this.type === 'blade' ? 2.5 : 1.2; 
                let angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.winding = 0; 
                this.ticksSinceHit = 0;
                this.path = [];
            }
            update(shadowBall) {
                this.x += this.vx; this.y += this.vy; this.ticksSinceHit++;
                if (!this.isShadow && shadowBall) {
                    let div = Math.sqrt((this.x-shadowBall.x)**2 + (this.y-shadowBall.y)**2);
                    chaosRatio = (chaosRatio * 0.999) + (div * 0.001); 
                }
                if (!this.isShadow && ticks % 5 === 0) {
                    this.path.push({x: this.x, y: this.y});
                    if (this.path.length > 40) this.path.shift(); 
                }
                let angle = Math.atan2(this.y, this.x);
                if (this.lastAngle !== undefined) {
                    let da = angle - this.lastAngle;
                    if (da > Math.PI) da -= 2 * Math.PI;
                    if (da < -Math.PI) da += 2 * Math.PI;
                    this.winding += da / (2 * Math.PI);
                }
                this.lastAngle = angle;
                this.checkBoundaries();
                if (this.ticksSinceHit > ZETA_VOID_LIMIT) {
                    this.x *= 0.1; this.y *= 0.1; this.vx *= -1; this.vy *= -1;
                    this.ticksSinceHit = 0;
                }
            }
            checkBoundaries() {
                let hit = false;
                if (simMode === 'discovery') {
                    if (this.x < discoveryBounds.minX || this.x > discoveryBounds.maxX) {
                        if (this.type === 'blade') { discoveryBounds.minX -= 0.05; discoveryBounds.maxX += 0.05; }
                        this.vx *= -1; this.x = this.x < discoveryBounds.minX ? discoveryBounds.minX : discoveryBounds.maxX;
                        hit = true;
                    }
                    if (this.y < discoveryBounds.minY || this.y > discoveryBounds.maxY) {
                        if (this.type === 'blade') { discoveryBounds.minY -= 0.05; discoveryBounds.maxY += 0.05; }
                        this.vy *= -1; this.y = this.y < discoveryBounds.minY ? discoveryBounds.minY : discoveryBounds.maxY;
                        hit = true;
                    }
                } else {
                    if (activeGeo.type === 'circle') {
                        let r = activeGeo.baseRadius * activeGeo.scale;
                        if (this.x*this.x + this.y*this.y > r*r) {
                            if (this.type === 'blade') activeGeo.scale += 0.0002;
                            let dist = Math.sqrt(this.x*this.x + this.y*this.y);
                            let nx = this.x / dist, ny = this.y / dist;
                            let dot = this.vx * nx + this.vy * ny;
                            if (dot > 0) { this.vx -= 2 * dot * nx; this.vy -= 2 * dot * ny; this.x = nx * r; this.y = ny * r; hit = true; }
                        }
                    } else {
                        let pts = getScaledPoints();
                        for (let i = 0; i < pts.length; i++) {
                            let p1 = pts[i], p2 = pts[(i+1)%pts.length];
                            let nx = -(p2[1]-p1[1]), ny = p2[0]-p1[0];
                            let len = Math.sqrt(nx*nx + ny*ny); nx /= len; ny /= len;
                            if (nx * (-p1[0]) + ny * (-p1[1]) < 0) { nx = -nx; ny = -ny; }
                            let d = (this.x-p1[0])*nx + (this.y-p1[1])*ny;
                            if (d < 0) {
                                if (this.type === 'blade') activeGeo.scale += 0.0002;
                                let dot = this.vx * (-nx) + this.vy * (-ny);
                                if (dot > 0) { this.vx -= 2 * dot * (-nx); this.vy -= 2 * dot * (-ny); hit = true; }
                            }
                        }
                    }
                }
                if (hit) this.ticksSinceHit = 0;
            }
        }

        let balls = [], shadowBalls = [];
        function initBalls() {
            balls = []; shadowBalls = [];
            discoveryBounds = { minX: -100, maxX: 100, minY: -100, maxY: 100 };
            activeGeo.scale = 1.0;
            ticks = 0;
            for (let g = 0; g < 7; g++) {
                for (let i = 0; i < 7; i++) {
                    let b = new Ball(g, false); balls.push(b);
                    let s = new Ball(g, true); s.x = b.x; s.y = b.y; s.vx = b.vx + 1e-7; s.vy = b.vy + 1e-7;
                    shadowBalls.push(s);
                }
            }
            currentConfigHash = (simMode === 'discovery' ? 'Disc_' : 'Plat_') + Math.random().toString(16).slice(2,10);
        }

        // --- 5. RENDER ---
        function draw() {
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = bgPattern; ctx.fillRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(2, 6, 23, 0.7)';
            ctx.beginPath(); ctx.rect(0, 0, width, height);
            if (simMode === 'discovery') {
                ctx.rect(CENTER_X + discoveryBounds.minX*baseScale, CENTER_Y + discoveryBounds.minY*baseScale, (discoveryBounds.maxX-discoveryBounds.minX)*baseScale, (discoveryBounds.maxY-discoveryBounds.minY)*baseScale);
            } else if (activeGeo.type === 'circle') {
                ctx.arc(CENTER_X, CENTER_Y, activeGeo.baseRadius * activeGeo.scale * baseScale, 0, Math.PI * 2, true);
            } else {
                let pts = getScaledPoints(); ctx.moveTo(CENTER_X + pts[0][0]*baseScale, CENTER_Y + pts[0][1]*baseScale);
                for(let i = pts.length - 1; i >= 0; i--) ctx.lineTo(CENTER_X + pts[i][0]*baseScale, CENTER_Y + pts[i][1]*baseScale);
            }
            ctx.fill("evenodd");

            ctx.globalCompositeOperation = 'hard-light'; 
            let maxDist = 150 * baseScale;
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    let dx = (balls[i].x - balls[j].x)*baseScale, dy = (balls[i].y - balls[j].y)*baseScale;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < maxDist) {
                        ctx.beginPath(); ctx.moveTo(CENTER_X + balls[i].x*baseScale, CENTER_Y + balls[i].y*baseScale);
                        ctx.lineTo(CENTER_X + balls[j].x*baseScale, CENTER_Y + balls[j].y*baseScale);
                        ctx.strokeStyle = balls[i].color + '44'; ctx.lineWidth = 0.5; ctx.stroke();
                    }
                }
            }
            ctx.globalCompositeOperation = 'source-over';
            balls.forEach(b => {
                ctx.beginPath(); ctx.arc(CENTER_X + b.x*baseScale, CENTER_Y + b.y*baseScale, (b.type === 'smith' ? 6 : 3) * baseScale, 0, Math.PI*2);
                ctx.fillStyle = fgPatterns[b.groupId]; ctx.fill();
            });
        }

        function loop() {
            let now = performance.now();
            fpsRolling = (fpsRolling * 0.9) + ((1000 / (now - lastFrameTime)) * 0.1);
            lastFrameTime = now;
            if (fpsRolling < 30) CHUNK_SIZE = Math.max(50, CHUNK_SIZE - 10);
            else if (fpsRolling > 55) CHUNK_SIZE = Math.min(800, CHUNK_SIZE + 5);

            for(let c=0; c < CHUNK_SIZE; c++) {
                balls.forEach((b, i) => b.update(shadowBalls[i]));
                shadowBalls.forEach(b => b.update(null)); 
                ticks++;
            }
            draw();
            if (dbConnected && ticks % 30000 === 0) {
                supabase.from('museum').upsert({ hash: currentConfigHash, chaos_ratio: chaosRatio.toFixed(2), tick_detected: ticks });
            }
            requestAnimationFrame(loop);
        }

        // --- 6. INTERFACE ---
        const title = document.getElementById('engine-title');
        const tabPlat = document.getElementById('tab-platonic');
        const tabDisc = document.getElementById('tab-discovery');
        const geoCont = document.getElementById('geo-selector-container');

        tabPlat.onclick = () => {
            simMode = 'platonic';
            title.textContent = "Platonic Boundary Sim";
            title.className = "text-xl md:text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-sky-400 to-indigo-500";
            tabPlat.className = "glass-panel px-3 py-1.5 rounded-lg text-sky-400 font-bold border-b-2 border-b-sky-400 transition";
            tabDisc.className = "glass-panel px-3 py-1.5 rounded-lg text-slate-400 hover:text-purple-300 transition";
            geoCont.style.display = 'flex';
            initBalls();
        };

        tabDisc.onclick = () => {
            simMode = 'discovery';
            title.textContent = "Boundary Discovery Engine";
            title.className = "text-xl md:text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-500";
            tabDisc.className = "glass-panel px-3 py-1.5 rounded-lg text-purple-400 font-bold border-b-2 border-b-purple-400 transition";
            tabPlat.className = "glass-panel px-3 py-1.5 rounded-lg text-slate-400 hover:text-sky-300 transition";
            geoCont.style.display = 'none';
            initBalls();
        };

        document.getElementById('geo-select').onchange = (e) => {
            activeGeo = geometries[e.target.value];
            initBalls();
        };

        // START
        initBalls();
        supabase.from('museum').select('count').then(({error}) => { if(!error) dbConnected = true; });
        loop();
    </script>
</body>
</html>